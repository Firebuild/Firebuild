#!/usr/bin/python3

# Copyright (c) 2020 Interri Kft.
# This file is an unpublished work. All rights reserved.

import os
import sys
from jinja2 import Environment, FileSystemLoader

if len(sys.argv) != 2:
  print("Usage: ./generate_fbb outputdir", file=sys.stderr)
  exit(1)
outdir = sys.argv[1]

env = Environment(loader=FileSystemLoader('.'),
                  line_statement_prefix='###',
                  trim_blocks=True,
                  lstrip_blocks=True,
                  keep_trailing_newline=True)

# Use a practically unique temporary filename, see #314
tmpsuffix = ".tmp." + str(os.getpid())

# Symbolic constants to reduce the chance of typos
REQUIRED = "required"
OPTIONAL = "optional"
STRING = "string"
STRINGARRAY = "stringarray"

################################################################################

def gen_fbb(msgs):
  for (msg, fields) in msgs:
    for (req, type, var) in fields:
      if req not in [REQUIRED, OPTIONAL]:
        print("Unknown value instead of REQUIRED or OPTIONAL", file=sys.stderr)
        exit(1)
      if type == STRINGARRAY and req != OPTIONAL:
        print("STRINGARRAY must be OPTIONAL", file=sys.stderr)
        exit(1)

  for extension in ["c", "h"]:
    template = env.get_template("tpl." + extension)
    rendered = template.render(msgs=msgs,
                               REQUIRED=REQUIRED,
                               OPTIONAL=OPTIONAL,
                               STRING=STRING,
                               STRINGARRAY=STRINGARRAY)
    if rendered:
      filename = outdir + "/fbb." + extension
      with open(filename + tmpsuffix, "w") as f:
        f.write(rendered)
      os.rename(filename + tmpsuffix, filename)

################################################################################

gen_fbb([
  # This is used by fbb_test.c.
  ("testing", [
    (REQUIRED, "int", "ri1"),
    (OPTIONAL, "int", "oi2"),
    (REQUIRED, "int", "ri3"),
    (OPTIONAL, "int", "oi4"),
    (REQUIRED, STRING, "rs5"),
    (OPTIONAL, STRING, "os6"),
    (REQUIRED, STRING, "rs7"),
    (OPTIONAL, STRING, "os8"),
    (OPTIONAL, STRINGARRAY, "sa9"),
    (OPTIONAL, STRINGARRAY, "sa10"),
  ]),

  # Temporary placeholder telling the supervisor to check shmq.
  ("shmq", []),

  # interceptor library queries FireBuild supervisor if it can shortcut execution of the process
  ("scproc_query", [
    # process id
    (OPTIONAL, "int64_t", "pid"),
    # parent pid
    (OPTIONAL, "int64_t", "ppid"),
    # working dir process started in
    (OPTIONAL, STRING, "cwd"),
    # only argv, sending argc would be redundant
    (OPTIONAL, STRINGARRAY, "arg"),
    # environment variables in unprocessed NAME=value form
    (OPTIONAL, STRINGARRAY, "env_var"),
    # full path of the binary
    (OPTIONAL, STRING, "executable"),
    # pathname used to execute the program
    (OPTIONAL, STRING, "executed_path"),
    # loaded shared libraries in the beginning
    (OPTIONAL, STRINGARRAY, "libs"),
    # interceptor's version
    (OPTIONAL, STRING, "version"),
  ]),

  # FireBuild supervisor's response with details of shortcutting.
  # Unlike the others, this message type is used in the supervisor->interceptor direction of the
  # communication. Nevertheless, it resides in the same namespace.
  ("scproc_resp", [
    (REQUIRED, "bool", "shortcut"),
    (OPTIONAL, "int64_t", "exit_status"),
    # disable interception and remove libfbintercept from LD_PRELOAD
    (OPTIONAL, "bool", "dont_intercept"),
    # makes sense only for shortcut = false
    (OPTIONAL, "int32_t", "debug_flags"),
    # fifos for fds to reopen
    # the format is "<fd>:<flags as int> <fifo path>"
    (OPTIONAL, STRINGARRAY, "reopen_fd_fifos"),
  ]),

  # Those function calls are not handled specially in interceptor lib and
  # are reported once per process to supervisor
  ("gen_call", [
    # function name
    (REQUIRED, STRING, "call"),
  ]),

  # FireBuild error
  ("fb_error", [
    # error message
    (REQUIRED, STRING, "msg"),
  ]),
  # FireBuild debugging message
  ("fb_debug", [
    # error message
    (REQUIRED, STRING, "msg"),
  ]),

  ("fcntl", [
    # file descriptor
    (OPTIONAL, "int32_t", "fd"),
    # command
    (OPTIONAL, "int32_t", "cmd"),
    # arg, if present
    (OPTIONAL, "int32_t", "arg"),
    # return value, depends on cmd
    (OPTIONAL, "int32_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("ioctl", [
    # file descriptor
    (OPTIONAL, "int32_t", "fd"),
    # command
    (OPTIONAL, "int32_t", "cmd"),
    # return value, depends on cmd
    (OPTIONAL, "int32_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("open", [
    # dir file descriptor for openat()
    (OPTIONAL, "int32_t", "dirfd"),
    # file path
    (OPTIONAL, STRING, "file"),
    # flags, decoding is left for FireBuild supervisor
    (REQUIRED, "int32_t", "flags"),
    # mode if (flags & O_CREAT), decoding is left for FireBuild supervisor
    (OPTIONAL, "int32_t", "mode"),
    # return value, the file descriptor if != -1
    (OPTIONAL, "int32_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("freopen", [
    # file path
    (OPTIONAL, STRING, "filename"),
    # flags, decoding is left for FireBuild supervisor
    (OPTIONAL, "int32_t", "flags"),
    # file descriptor associated to the stream to be reopened
    (OPTIONAL, "int32_t", "fd"),
    # return value, the file descriptor if != -1
    (OPTIONAL, "int32_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("chdir", [
    # directory path
    (OPTIONAL, STRING, "dir"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("fchdir", [
    # directory fd
    (OPTIONAL, "int64_t", "fd"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("readlink", [
    # dir file descriptor for readlinkat()
    (OPTIONAL, "int64_t", "dirfd"),
    # path name
    (OPTIONAL, STRING, "path"),
    # buffer size
    (OPTIONAL, "int32_t", "bufsiz"),
    # returned path
    (OPTIONAL, STRING, "ret_path"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("rename", [
    # old dir file descriptor for renameat[2]()
    (OPTIONAL, "int32_t", "olddirfd"),
    # path to old file
    (OPTIONAL, STRING, "oldpath"),
    # new dir file descriptor for renameat[2]()
    (OPTIONAL, "int32_t", "newdirfd"),
    # path to new file
    (OPTIONAL, STRING, "newpath"),
    # flags for renmaeat2()
    (OPTIONAL, "int32_t", "flags"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("access", [
    # path to file
    (OPTIONAL, STRING, "pathname"),
    # acess mode
    (OPTIONAL, "int32_t", "mode"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("euidaccess", [
    # path to file
    (OPTIONAL, STRING, "pathname"),
    # access mode
    (OPTIONAL, "int32_t", "mode"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("faccessat", [
    # dir file descriptor
    (OPTIONAL, "int64_t", "dirfd"),
    # path to file
    (OPTIONAL, STRING, "pathname"),
    # access mode
    (OPTIONAL, "int32_t", "mode"),
    # flags
    (OPTIONAL, "int32_t", "flags"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("stat", [
    # dir file descriptor for fstatat()
    (OPTIONAL, "int32_t", "dirfd"),
    # path to file
    (OPTIONAL, STRING, "filename"),
    # it was actually lstat() or fstatat(..., AT_SYMLINK_NOFOLLOW), so don't follow symlink
    (OPTIONAL, "bool", "link"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("fstat", [
    # file fd
    (OPTIONAL, "int32_t", "fd"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("mkdir", [
    # dir file descriptor for mkdirat()
    (OPTIONAL, "int", "dirfd"),
    # dir path
    (OPTIONAL, STRING, "pathname"),
    # mode
    (REQUIRED, "mode_t", "mode"),
    # error no., when ret = -1
    (OPTIONAL, "int", "error_no"),
  ]),

  ("rmdir", [
    # dir path
    (OPTIONAL, STRING, "pathname"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("close", [
    # file descriptor
    (OPTIONAL, "int64_t", "fd"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("fcloseall", [
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("chmod", [
    # dir file descriptor for fchmodat()
    (OPTIONAL, "int32_t", "dirfd"),
    # file path
    (OPTIONAL, STRING, "path"),
    # mode
    (OPTIONAL, "int32_t", "mode"),
    # flags for fchmodat()
    (OPTIONAL, "int32_t", "flags"),
    # it was actually lchmod() or fchmodat(..., AT_SYMLINK_NOFOLLOW), so don't follow symlink
    (OPTIONAL, "bool", "link"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("fchmod", [
    # file fd
    (OPTIONAL, "int32_t", "fd"),
    # mode
    (OPTIONAL, "int32_t", "mode"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("chown", [
    # dir file descriptor for fchownat()
    (OPTIONAL, "int32_t", "dirfd"),
    # file path
    (OPTIONAL, STRING, "path"),
    # uid
    (OPTIONAL, "int32_t", "owner"),
    # gid
    (OPTIONAL, "int32_t", "group"),
    # flags for fchownat()
    (OPTIONAL, "int32_t", "flags"),
    # it was actually lchown() or fchownat(..., AT_SYMLINK_NOFOLLOW), so don't follow symlink
    (OPTIONAL, "bool", "link"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("fchown", [
    # file fd
    (OPTIONAL, "int32_t", "fd"),
    # uid
    (OPTIONAL, "int32_t", "owner"),
    # gid
    (OPTIONAL, "int32_t", "group"),
    # flags for fchownat()
    (OPTIONAL, "int32_t", "flags"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("unlink", [
    # dir file descriptor for unlinkat()
    (OPTIONAL, "int32_t", "dirfd"),
    # path name
    (OPTIONAL, STRING, "pathname"),
    # flags for unlinkat()
    (OPTIONAL, "int32_t", "flags"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("link", [
    # old dir file descriptor for linkat()
    (OPTIONAL, "int32_t", "olddirfd"),
    # old file path
    (OPTIONAL, STRING, "oldpath"),
    # new dir file descriptor for linkat()
    (OPTIONAL, "int32_t", "newdirfd"),
    # new file path
    (OPTIONAL, STRING, "newpath"),
    # flags for linkat()
    (OPTIONAL, "int32_t", "flags"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("symlink", [
    # old file path
    (OPTIONAL, STRING, "oldpath"),
    # new dir file descriptor for symlinkat()
    (OPTIONAL, "int32_t", "newdirfd"),
    # new file path
    (OPTIONAL, STRING, "newpath"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("lockf", [
    # file fd
    (OPTIONAL, "int32_t", "fd"),
    # lock command
    (OPTIONAL, "int32_t", "cmd"),
    # file range
    (OPTIONAL, "int64_t", "len"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("utime", [
    # ..at(), like utimensat
    (OPTIONAL, "int32_t", "dirfd"),
    # file name
    (OPTIONAL, STRING, "file"),
    # it was actually lutime() or utimensat(..., AT_SYMLINK_NOFOLLOW), so don't follow symlink
    (OPTIONAL, "bool", "link"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("futime", [
    # file fd
    (OPTIONAL, "int32_t", "fd"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  # pipe2() with flags = 0 is equivalent to pipe()
  ("pipe2", [
    # pipe fd[0] in case of success
    (OPTIONAL, "int32_t", "fd0"),
    # pipe fd[1] in case of success
    (OPTIONAL, "int32_t", "fd1"),
    # flags
    (OPTIONAL, "int32_t", "flags"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
    # named pipe which is read by the intercepted process when reading fd[0]
    (OPTIONAL, STRING, "fd0_fifo"),
    # named pipe which is written by the intercepted process when reading fd[1]
    (OPTIONAL, STRING, "fd1_fifo"),
  ]),

  # for dup
  ("dup", [
    # old file fd
    (REQUIRED, "int32_t", "oldfd"),
    # new fd
    (REQUIRED, "int32_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  # for dup2 and dup3
  ("dup3", [
    # old file fd
    (REQUIRED, "int32_t", "oldfd"),
    # new file fd
    (REQUIRED, "int32_t", "newfd"),
    # flags
    (OPTIONAL, "int32_t", "flags"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("dlopen", [
    # file path
    (OPTIONAL, STRING, "filename"),
    # flag, decoding is left for FireBuild supervisor
    (OPTIONAL, "int32_t", "flag"),
    # absolute filename where (if) the library was found
    (OPTIONAL, STRING, "absolute_filename"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("execv", [
    # file to execute
    (OPTIONAL, STRING, "file"),
    # file fd to execute, in case of fexecve()
    (OPTIONAL, "int32_t", "fd"),
    # dir fd to execute, in case of execveat()
    (OPTIONAL, "int32_t", "dirfd"),
    # argv[]
    (OPTIONAL, STRINGARRAY, "arg"),
    # envp[]
    (OPTIONAL, STRINGARRAY, "env"),
    # true, in case of execvp()/execvpe()
    (OPTIONAL, "bool", "with_p"),
    # PATH, or confstr(_CS_PATH) if PATH is not set
    (OPTIONAL, STRING, "path"),
    # user CPU time in microseconds since last exec()
    (REQUIRED, "int64_t", "utime_u"),
    # system CPU time in microseconds since laste exec()
    (REQUIRED, "int64_t", "stime_u"),
  ]),

  ("execv_failed", [
    # error no., when ret = -1
    (REQUIRED, "int32_t", "error_no"),
  ]),

  # system(3)
  ("system", [
    # command, only SystemRet is sent when command was NULL
    (REQUIRED, STRING, "cmd"),
    # return value is sent in SystemRet
  ]),

  ("system_ret", [
    # command, not present when it was NULL
    (OPTIONAL, STRING, "cmd"),
    # return value
    (REQUIRED, "int64_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  # popen(3)
  ("popen", [
    # command
    (OPTIONAL, STRING, "cmd"),
    # type, represented as flags
    (REQUIRED, "int32_t", "type_flags"),
  ]),

  ("popen_parent", [
    # return value
    (REQUIRED, "int32_t", "fd"),
    # fifo
    (OPTIONAL, STRING, "fifo"),
  ]),

  ("popen_failed", [
    # command, to let the supervisor remove it from expected_children
    (OPTIONAL, STRING, "cmd"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("pclose", [
    # file descriptor
    (REQUIRED, "int32_t", "fd"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  # posix_spawn[p](3)
  ("posix_spawn", [
    # command
    (OPTIONAL, STRING, "file"),
    # only argv, sending argc would be redundant
    (OPTIONAL, STRINGARRAY, "arg"),
    # environment variables in unprocessed NAME=value form
    (OPTIONAL, STRINGARRAY, "env"),
    # spawn or spawnp
    (REQUIRED, "bool", "is_spawnp"),
  ]),

  ("posix_spawn_parent", [
    # command args repeated, to let the supervisor remove it from expected_child
    (OPTIONAL, STRINGARRAY, "arg"),
    # posix_spawn_file_actions_t, each action encoded in one string
    (OPTIONAL, STRINGARRAY, "file_actions"),
    # child's process id
    (REQUIRED, "int64_t", "pid"),
  ]),

  ("posix_spawn_failed", [
    # command args repeated, to let the supervisor remove it from expected_child
    (OPTIONAL, STRINGARRAY, "arg"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("wait", [
    # pid whose termination the parent has successfully waited for
    (REQUIRED, "int64_t", "pid"),
  ]),

  ("sysconf", [
    # name
    (OPTIONAL, "int64_t", "name"),
    # value
    (OPTIONAL, "int64_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("syscall", [
    # syscall number (id)
    (OPTIONAL, "int64_t", "number"),
    # return value
    (OPTIONAL, "int64_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("gethostname", [
    # name
    (OPTIONAL, STRING, "name"),
    # value
    (OPTIONAL, "int64_t", "len"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("getdomainname", [
    # name
    (OPTIONAL, STRING, "name"),
    # value
    (OPTIONAL, "int64_t", "len"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("truncate", [
    # name
    (OPTIONAL, STRING, "path"),
    # length
    (OPTIONAL, "int64_t", "len"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("ftruncate", [
    # file fd
    (OPTIONAL, "int32_t", "fd"),
    # length
    (OPTIONAL, "int64_t", "len"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("pathconf", [
    # path name
    (OPTIONAL, STRING, "path"),
    # option name
    (OPTIONAL, "int32_t", "name"),
    # option value
    (OPTIONAL, "int64_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("fpathconf", [
    # file fd
    (OPTIONAL, "int32_t", "fd"),
    # option name
    (OPTIONAL, "int32_t", "name"),
    # option value
    (OPTIONAL, "int64_t", "ret"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("read", [
    # file fd
    (REQUIRED, "int32_t", "fd"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("write", [
    # file fd
    (REQUIRED, "int32_t", "fd"),
    # error no., when ret = -1
    (OPTIONAL, "int32_t", "error_no"),
  ]),

  ("exit", [
    # exit status of the process
    (REQUIRED, "int32_t", "exit_status"),
    # user CPU time in microseconds
    (REQUIRED, "int64_t", "utime_u"),
    # system CPU time in microseconds
    (REQUIRED, "int64_t", "stime_u"),
  ]),

  # fork()'s child
  ("fork_child", [
    # process id
    (REQUIRED, "int64_t", "pid"),
    # process parent id
    (REQUIRED, "int64_t", "ppid"),
  ]),

  # process that called fork()
  ("fork_parent", [
    # child process id
    (REQUIRED, "int64_t", "pid"),
  ]),
])
