/* Copyright (c) 2014 Balint Reczey <balint@balintreczey.hu> */
/* This file is an unpublished work. All rights reserved. */

// Protocol Buffer definitions for FireBuild
// Copyright (c) 2013 Balint Reczey.  All rights reserved.

syntax = "proto2";

package firebuild.msg;

// interceptor library queries FireBuild supervisor if it can shortcut execution of the process
message ShortCutProcessQuery {
    // process id
    optional int64 pid = 1;
    // parent pid
    optional int64 ppid = 2;
    // working dir process started in
    optional bytes cwd = 3;
    // only argv, sending argc would be redundant
    repeated bytes arg = 4;
    // environment variables in unprocessed NAME=value form
    repeated bytes env_var = 5;
    // full path of the binary
    optional bytes executable = 6;
    // loaded shared libraries in the beginning
    optional FileList libs = 7;
}

// FireBuild supervisor's response with details of shortcutting
message ShortCutProcessResp {
    required bool shortcut = 1;
    optional int64 exit_status = 2;
    // makse sense only for shortcut = false
    optional int32 debug_flags = 3;
}

// Those function calls are not handled specially in interceptor lib and
// are reported once per process to supervisor
message GenericCall {
    // function name
    required bytes call = 1;
}

// FireBuild error
message FBError {
    // error message
    required string msg = 1;
}
// FireBuild debugging message
message FBDebug {
    // error message
    required string msg = 1;
}

message Fcntl {
    // file descriptor
    optional int32 fd = 1;
    // command
    optional int32 cmd = 2;
    // arg, if present
    optional int32 arg = 3;
    // return value, depends on cmd
    optional int32 ret = 4;
    // error no., when ret = -1
    optional int32 error_no = 5;
}

message Ioctl {
    // file descriptor
    optional int32 fd = 1;
    // command
    optional int32 cmd = 2;
    // return value, depends on cmd
    optional int32 ret = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message Open {
    // dir file descriptor for openat()
    optional int32 dirfd = 1;
    // file path
    optional bytes file = 2;
    // flags, decoding is left for FireBuild supervisor
    required int32 flags = 3;
    // mode if (flags & O_CREAT), decoding is left for FireBuild supervisor
    optional int32 mode = 4;
    // return value, the file descriptor if != -1
    optional int32 ret = 5;
    // error no., when ret = -1
    optional int32 error_no = 6;
}

message FReOpen {
    // file path
    optional bytes filename = 1;
    // flags, decoding is left for FireBuild supervisor
    optional int32 flags = 2;
    // file descriptor associated to the stream to be reopened
    optional int32 fd = 3;
    // return value, the file descriptor if != -1
    optional int32 ret = 4;
    // error no., when ret = -1
    optional int32 error_no = 5;
}

message OpenFileResp {
    // true if interceptor library needs to collect file state and send back
    // to supervisor
    optional bool collect_state = 1;
}

message ChDir {
    // directory path
    optional bytes dir = 1;
    // error no., when ret = -1
    optional int32 error_no = 2;
}

message FChDir {
    // directory fd
    optional int64 fd = 1;
    // error no., when ret = -1
    optional int32 error_no = 2;
}

message ReadLink {
    // dir file descriptor for readlinkat()
    optional int64 dirfd = 1;
    // path name
    optional bytes path = 2;
    // buffer size
    optional int32 bufsiz = 3;
    // returned path
    optional bytes ret_path = 4;
    // error no., when ret = -1
    optional int32 error_no = 5;
}

message Rename {
    // old dir file descriptor for renameat[2]()
    optional int32 oldfd = 1;
    // path to old file
    optional bytes oldpath = 2;
    // new dir file descriptor for renameat[2]()
    optional int32 newfd = 3;
    // path to new file
    optional bytes newpath = 4;
    // flags for renmaeat2()
    optional int32 flags = 5;
    // error no., when ret = -1
    optional int32 error_no = 6;
}

message Access {
    // path to file
    optional bytes pathname = 1;
    // acess mode
    optional int32 mode = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message EuidAccess {
    // path to file
    optional bytes pathname = 1;
    // access mode
    optional int32 mode = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message FAccessAt {
    // dir file descriptor
    optional int64 dirfd = 1;
    // path to file
    optional bytes pathname = 2;
    // access mode
    optional int32 mode = 3;
    // flags
    optional int32 flags = 4;
    // error no., when ret = -1
    optional int32 error_no = 5;
}

message Stat {
    // dir file descriptor for fstatat()
    optional int32 dirfd = 1;
    // path to file
    optional bytes filename = 2;
    // it was actually lstat() or fstatat(..., AT_SYMLINK_NOFOLLOW), so don't follow symlink
    optional bool link = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message FStat {
    // file fd
    optional int32 fd = 1;
    // error no., when ret = -1
    optional int32 error_no = 2;
}

message RmDir {
    // dir path
    optional bytes dir = 1;
    // error no., when ret = -1
    optional int32 error_no = 2;
}

message Close {
    // file descriptor
    optional int64 fd = 1;
    // error no., when ret = -1
    optional int32 error_no = 2;
}

message FCloseAll {
    // error no., when ret = -1
    optional int32 error_no = 1;
}

message Chmod {
    // dir file descriptor for fchmodat()
    optional int32 dirfd = 1;
    // file path
    optional bytes path = 2;
    // mode
    optional int32 mode = 3;
    // flags for fchmodat()
    optional int32 flags = 4;
    // it was actually lchmod() or fchmodat(..., AT_SYMLINK_NOFOLLOW), so don't follow symlink
    optional bool link = 5;
    // error no., when ret = -1
    optional int32 error_no = 6;
}

message FChmod {
    // file fd
    optional int32 fd = 1;
    // mode
    optional int32 mode = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message Chown {
    // dir file descriptor for fchownat()
    optional int32 dirfd = 1;
    // file path
    optional bytes path = 2;
    // uid
    optional int32 owner = 3;
    // gid
    optional int32 group = 4;
    // flags for fchownat()
    optional int32 flags = 5;
    // it was actually lchown() or fchownat(..., AT_SYMLINK_NOFOLLOW), so don't follow symlink
    optional bool link = 6;
    // error no., when ret = -1
    optional int32 error_no = 7;
}

message FChown {
    // file fd
    optional int32 fd = 1;
    // uid
    optional int32 owner = 2;
    // gid
    optional int32 group = 3;
    // flags for fchownat()
    optional int32 flags = 4;
    // error no., when ret = -1
    optional int32 error_no = 5;
}

message UnLink {
    // dir file descriptor for unlinkat()
    optional int32 dirfd = 1;
    // path name
    optional bytes pathname = 2;
    // flags for unlinkat()
    optional int32 flags = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message Link {
    // old dir file descriptor for linkat()
    optional int32 olddirfd = 1;
    // old file path
    optional bytes oldpath = 2;
    // new dir file descriptor for linkat()
    optional int32 newdirfd = 3;
    // new file path
    optional bytes newpath = 4;
    // flags for linkat()
    optional int32 flags = 5;
    // error no., when ret = -1
    optional int32 error_no = 6;
}

message Symlink {
    // old file path
    optional bytes oldpath = 1;
    // new dir file descriptor for symlinkat()
    optional int32 newdirfd = 2;
    // new file path
    optional bytes newpath = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message LockF {
    // file fd
    optional int32 fd = 1;
    // lock command
    optional int32 cmd = 2;
    // file range
    optional int64 len = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message UTime {
    // ..at(), like utimensat
    optional int32 dirfd = 1;
    // file name
    optional bytes file = 2;
    // it was actually lutime() or utimensat(..., AT_SYMLINK_NOFOLLOW), so don't follow symlink
    optional bool link = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message FUTime {
    // file fd
    optional int32 fd = 1;
    // error no., when ret = -1
    optional int32 error_no = 2;
}

// pipe2() with flags = 0 is equivalent to pipe()
message Pipe2 {
    // pipe fd[0] in case of success
    optional int32 fd0 = 1;
    // pipe fd[1] in case of success
    optional int32 fd1 = 2;
    // flags
    optional int32 flags = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

// for dup
message Dup {
    // old file fd
    required int32 oldfd = 1;
    // new fd
    required int32 ret = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

// for dup2 and dup3
message Dup3 {
    // old file fd
    required int32 oldfd = 1;
    // new file fd
    required int32 newfd = 2;
    // flags
    optional int32 flags = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message DLOpen {
    // file path
    optional bytes filename = 1;
    // flag, decoding is left for FireBuild supervisor
    optional int32 flag = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message ExecV {
    // file to execute
    optional bytes file = 1;
    // file fd to execute, in case of fexecve()
    optional int32 fd = 2;
    // dir fd to execute, in case of execveat()
    optional int32 dirfd = 3;
    // argv[]
    repeated bytes arg = 4;
    // envp[]
    repeated bytes env = 5;
    // true, in case of execvp()/execvpe()
    optional bool with_p = 6;
    // PATH, or confstr(_CS_PATH) if PATH is not set
    optional bytes path = 7;
    // user CPU time in microseconds
    required int64 utime_u = 8;
    // system CPU time in microseconds
    required int64 stime_u = 9;
}

message ExecVFailed {
    // error no., when ret = -1
    required int32 error_no = 1;
}

// system(3)
message System {
    // command, only SystemRet is sent when command was NULL
    required bytes cmd = 1;
    // return value is sent in SystemRet
}

message SystemRet {
    // command, not present when it was NULL
    optional bytes cmd = 1;
    // return value
    required int64 ret = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

// popen(3)
message Popen {
    // command
    optional bytes cmd = 1;
    // type
    optional bytes type = 2;
}

message PopenParent {
    // return value
    required int32 fd = 1;
}

message PopenFailed {
    // command, to let the supervisor remove it from expected_children
    optional bytes cmd = 1;
    // error no., when ret = -1
    optional int32 error_no = 2;
}

// posix_spawn[p](3)
message PosixSpawn {
    // command
    optional bytes file = 1;
    // only argv, sending argc would be redundant
    repeated bytes arg = 2;
    // environment variables in unprocessed NAME=value form
    repeated bytes env = 3;
    // spawn or spawnp
    required bool is_spawnp = 4;
    // posix_spawn_file_actions_t translated into protobuf
    optional PosixSpawnFileActions file_actions = 5;
}

message PosixSpawnParent {
    // process id
    required int64 pid = 1;
    // child's process id
    optional int64 child_pid = 2;
    // unused
    optional int32 error_no = 3;
}

message PosixSpawnFailed {
    // command args, to let the supervisor remove it from expected_children
    repeated bytes arg = 1;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message Sysconf {
    // name
    optional int64 name = 1;
    // value
    optional int64 ret = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message SysCall {
    // syscall number (id)
    optional int64 number = 1;
    // return value
    optional int64 ret = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message GetHostname {
    // name
    optional bytes name = 1;
    // value
    optional int64 len = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message GetDomainname {
    // name
    optional bytes name = 1;
    // value
    optional int64 len = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message Truncate {
    // name
    optional bytes path = 1;
    // lenght
    optional int64 len = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message FTruncate {
    // file fd
    optional int32 fd = 1;
    // lenght
    optional int64 len = 2;
    // error no., when ret = -1
    optional int32 error_no = 3;
}

message PathConf {
    // path name
    optional bytes path = 1;
    // option name
    optional int32 name = 2;
    // option value
    optional int64 ret = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message FPathConf {
    // file fd
    optional int32 fd = 1;
    // option name
    optional int32 name = 2;
    // option value
    optional int64 ret = 3;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message Read {
    // file fd
    required int32 fd = 1;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message Write {
    // file fd
    required int32 fd = 1;
    // error no., when ret = -1
    optional int32 error_no = 4;
}

message FileList {
    repeated bytes file = 1;
}

message DLClose {
    // loaded shared libraries before dlclose
    optional FileList libs = 1;
}
message Exit {
    // exit status of the process
    required int32 exit_status = 1;
    // user CPU time in microseconds
    required int64 utime_u = 2;
    // system CPU time in microseconds
    required int64 stime_u = 3;
    // loaded shared libraries at exit
    optional FileList libs = 4;
}

// fork()'s child
message ForkChild {
    // process id
    required int64 pid = 1;
    // process parent id
    required int64 ppid = 2;
}

// process that called fork()
message ForkParent {
    // child process id
    // FIXME - the pid is already known in the supervisor???
    required int64 pid = 1;
}

message LAObjSearch {
    // file name
    required bytes name = 1;
    // search flag
    required int32 flag = 2;
}

message LAObjOpen {
    // file name
    required bytes name = 1;
}

// wrapper for messages supervisor can send
message SupervisorMsg {
    optional ShortCutProcessResp scproc_resp= 1;
    optional OpenFileResp open_file_resp = 2;
    // ACK id, if sent in the corresponding InterceptorMessage
    optional int64 ack_num = 3;
}

// wrapper for messages interceptor can send
message InterceptorMsg {
    // ACK id, to be sent back in SupervisorMsg
    optional int64 ack_num = 1;
    oneof x_function {
        ShortCutProcessQuery scproc_query = 2;
        Open open = 3;
        Close close = 4;
        GenericCall gen_call = 6;
        Exit exit = 7;
        ForkChild fork_child = 8;
        ForkParent fork_parent = 9;
        ChDir chdir = 11;
        FChDir fchdir = 12;
        RmDir rmdir = 14;
        Chmod chmod = 15;
        FChmod fchmod = 16;
        Chown chown = 17;
        FChown fchown = 18;
        UnLink unlink = 19;
        Link link = 20;
        Symlink symlink = 22;
        LockF lockf = 24;
        Pipe2 pipe2 = 25;
        Sysconf sysconf = 26;
        Dup dup = 27;
        Dup3 dup3 = 28;
        ReadLink readlink = 29;
        Access access = 31;
        EuidAccess euidaccess = 32;
        FAccessAt faccessat = 33;
        ExecV execv = 34;
        ExecVFailed execvfailed = 35;
        GetHostname gethostname = 36;
        GetDomainname getdomainname = 37;
        Truncate truncate = 38;
        FTruncate ftruncate = 39;
        PathConf pathconf = 40;
        FPathConf fpathconf = 41;
        Read read = 42;
        Write write = 43;
        Rename rename = 45;
        DLOpen dlopen = 47;
        FReOpen freopen = 49;
        FCloseAll fcloseall = 50;
        LAObjSearch la_objsearch = 51;
        LAObjOpen la_objopen = 52;
        DLClose dlclose = 53;
        UTime utime = 55;
        FUTime futime = 56;
        FBError fb_error = 57;
        FBDebug fb_debug = 58;
        Fcntl fcntl = 59;
        Ioctl ioctl = 60;
        SysCall syscall = 61;
        System system = 62;
        SystemRet system_ret = 63;
        Popen popen = 64;
        PopenParent popen_parent = 65;
        PopenFailed popen_failed = 66;
        PosixSpawn posix_spawn = 67;
        PosixSpawnParent posix_spawn_parent = 68;
        PosixSpawnFailed posix_spawn_failed = 69;
        Stat stat = 70;
        FStat fstat = 71;
    }
}

message PosixSpawnFileActionOpen {
    required int32 fd = 1;
    required bytes path = 2;
    required int32 flags = 3;
    required int32 mode = 4;
}

message PosixSpawnFileActionClose {
    required int32 fd = 1;
}

message PosixSpawnFileActionDup2 {
    required int32 oldfd = 1;
    required int32 newfd = 2;
}

message PosixSpawnFileAction {
    oneof x_action {
        PosixSpawnFileActionOpen open = 1;
        PosixSpawnFileActionClose close = 2;
        PosixSpawnFileActionDup2 dup2 = 3;
    }
}

// the protobuf equivalent of posix_spawn_file_actions_t
message PosixSpawnFileActions {
    repeated PosixSpawnFileAction action = 1;
}
