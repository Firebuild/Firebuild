/* Copyright (c) 2014 Balint Reczey <balint@balintreczey.hu> */
/* This file is an unpublished work. All rights reserved. */

// Flatbuffer definitions for FireBuild
// Copyright (c) 2013 Balint Reczey.  All rights reserved.

namespace firebuild.msg;

file_identifier "FBCO";

// File state
table File {
  // file path, absolute or relative
  path:string (key);
  // checksum (binary) of the file content, unset if file is not found
  hash:[ubyte];
  // TODO add alternate hash values generated after preprocessing the file
  // with programs keeping the semantic content (e.g. removing white spaces
  // alt_hash:[ubyte];

  // last modification time
  mtime:long;
  // file size, length in case of stdio
  size:long;
  // TODO refine mode
  mode:int = -1;
  // The reason why the file could not be opened.
  error_no:int;
}

table Dir {
  path:string (required);
  entry:[string];
}

table PipeFds {
  // Client-side fds pointing to the same pipe
  fd:[int];
}

table PipeData {
  // fd at the time the process started, the lowest one if dup()'ed to
  // multiple fds
  fd:int;
  // Checksum (binary) of the written data
  hash:[ubyte];
}

// Properties of a process that are known when it starts up, and are
// expected to be the same across identical launches. These take a key
// part in deciding whether it can be shortcutted. This includes command
// line flags, selected environment variables and such. Things that are
// expected to change across runs, e.g. pid, ppid, $FB_SOCKET etc. are
// not included here. Things that only become known while the process is
// running, such as the files it reads, aren't included either.
table ProcessFingerprint {
  // Program file
  executable:File (required);
  // Pathname used to execute the program
  executed_path:File (required);
  // Libraries loaded upon startup
  libs:[File];
  // Command parameters, starting with name of the command
  args:[string];
  // Environment variables, filtered (to exclude e.g. $FB_SOCKET)
  // and sorted to a deterministic order
  env:[string];
  // The initial working directory
  wd:string (required);
  // For each outbound pipe, this contains the client-side fds
  outbound_pipe:[PipeFds];
  // special purpose file descriptors, not having file name
  //optional stdin:File;
  //optional stdout:File;
  //optional stderr:File;

  // Other initially opened file descriptors?
  // seek positions from fdinfo?
}

// Things that are read from the external world by the process while
// it's running, but aren't known in advance that the process will need
// them. In order to shortcut a process, there has to be a cached entry
// that matches the current world.
table ProcessInputs {
  // Files that are opened for reading, with various results.
  path_isreg_with_hash:[File];
  system_path_isreg_with_hash:[File];
  path_isreg:[string];
  path_isdir_with_hash:[File];
  system_path_isdir_with_hash:[File];
  path_isdir:[string];
  path_notexist_or_isreg:[string];
  path_notexist_or_isreg_empty:[string];
  path_notexist:[string];

  // Files and directories that are stat'ed, even if stat failed.
  //path_stated[File];

  // TODO: Directories that are opendir'ed, even if opendir failed.
  // FIXME: need to fingerprint the entire directory listing??
  //path_isdir_listed[Dir];

  // TODO: readlink and friends...
}

// Things that are modified in the external world by the process while
// it's running.
table ProcessOutputs {
  // Files that are written to (or removed), only if opening them for
  // writing succeeded.
  path_isreg_with_hash:[File];
  // Directories created
  path_isdir:[File];
  path_notexist:[string];
  // Maybe special handling of files that are appended to?

  // TODO:
  // unlink, rmdir
  // link, symlink
  // chown, chmod
  // etc.

  // Data written to inherited pipes
  pipe_data:[PipeData];

  exit_status:int;
}

table ProcessInputsOutputs {
  inputs:ProcessInputs;
  outputs:ProcessOutputs (required);
}

table Process {
  // process id
  pid:long;
  // Checksum (binary) of process and children
  hash:[ubyte];
  fingerprint:ProcessFingerprint (required);
  inputs_outputs:ProcessInputsOutputs (required);
  // exit status of the process
  exit_status:int;
  child_hash:[string];
  // TODO
  // signals?
}

root_type ProcessInputsOutputs;
