/* Copyright (c) 2014 Balint Reczey <balint@balintreczey.hu> */
/* This file is an unpublished work. All rights reserved. */

// Protocol Buffer definitions for FireBuild
// Copyright (c) 2013 Balint Reczey.  All rights reserved.

syntax = "proto2";

package firebuild.msg;

// Message for storing and retrieving the content of a file
message FileContent {
    required bytes hash = 1; // checksum (binary) of the file content
    required bytes content = 2; // file content as raw bytes
}

// File state
message File {
    // file path, absolute or relative
    optional bytes path = 1;

    // checksum (binary) of the file content, unset if file is not found
    optional bytes hash = 2;

    // TODO add alternate hash values generated after preprocessing the file
    // with programs keeping the semantic content (e.g. removing white spaces)
    //repeated AltHash alt_hash = 3;

    // last modification time
    optional int64 mtime = 4;

    // file size, length in case of stdio
    optional int64 size = 5;

    // TODO refine mode
    optional int32 mode = 6;

    // The reason why the file could not be opened.
    optional int32 error_no = 7;
}

message Dir {
    required bytes path = 1;
    repeated bytes entry = 2;
}

message EnvVar {
    required bytes name = 1;
    required bytes value = 2;
}

// Properties of a process that are known when it starts up, and are
// expected to be the same across identical launches. These take a key
// part in deciding whether it can be shortcutted. This includes command
// line flags, selected environment variables and such. Things that are
// expected to change across runs, e.g. pid, ppid, $FB_SOCKET etc. are
// not included here. Things that only become known while the process is
// running, such as the files it reads, aren't included either.
message ProcessDescription {
    // Program file
    required File executable = 1;

    // Libraries loaded upon startup
    repeated File libs = 2;

    // Command parameters, starting with name of the command
    repeated bytes arg = 3;

    // Environment variables, filtered (to exclude e.g. $FB_SOCKET)
    // and sorted to a deterministic order
    repeated bytes env = 4;

    // The initial working directory
    required bytes cwd = 5;

    // special purpose file descriptors, not having file name
    //optional File stdin = 6;
    //optional File stdout = 7;
    //optional File stderr = 8;

    // Other initially opened file descriptors?
    // seek positions from fdinfo?
}

// Things that are read from the external world by the process while
// it's running, but aren't known in advance that the process will need
// them. In order to shortcut a process, there has to be a cached entry
// that matches the current world.
message ProcessInputs {
    // Files that are opened for reading, with various results.
    repeated File file_exist_with_hash = 1;
    repeated bytes file_exist = 2;
    repeated bytes file_notexist_or_empty = 3;
    repeated bytes file_notexist = 4;

    // Files and directories that are stat'ed, even if stat failed.
    //repeated File file_stated = 5;

    // TODO: Directories that are opendir'ed, even if opendir failed.
    // FIXME: need to fingerprint the entire directory listing??
    // repeated Dir dir_listed = 6;

    // TODO: readlink and friends...
}

// Things that are modified in the external world by the process while
// it's running.
message ProcessOutputs {
    // Files that are written to (or removed), only if opening them for
    // writing succeeded.
    repeated File file_with_hash = 1;
    repeated bytes file_notexist = 2;

    // Maybe special handling of files that are appended to?

    // TODO:
    // mkdir
    // unlink, rmdir
    // link, symlink
    // chown, chmod
    // etc.
}

message ProcessInputsOutputs {
    required ProcessInputs inputs = 1;
    required ProcessOutputs outputs = 2;
}

message Process {
    // process id
    optional int64 pid = 1;
    // Checksum (binary) of process and children
    optional bytes hash = 2;

    required ProcessDescription descr = 3;
    required ProcessInputsOutputs inputs_outputs = 4;

    // exit status of the process
    optional int32 exit_status = 5;

    // child processes referenced by checksum (binary)
    repeated bytes child_hash = 6;
    // TODO
    // signals?
    //
}
