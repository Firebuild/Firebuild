#!/usr/bin/env python3

# Copyright (c) 2014 Balint Reczey <balint@balintreczey.hu>
# Copyright (c) 2020 Interri Kft.
# This file is an unpublished work. All rights reserved.


import os
import sys
from jinja2 import Environment, FileSystemLoader


if len(sys.argv) != 2:
  print("Usage: ./generate_interceptors outputdir", file=sys.stderr)
  exit(1)
outdir = sys.argv[1]

outputs = ['decl.h', 'def.c', 'impl.c', 'init.c', 'list.txt', 'reset.c']
env = Environment(loader=FileSystemLoader('.'),
                  line_statement_prefix='###',
                  trim_blocks=True,
                  lstrip_blocks=True,
                  keep_trailing_newline=True,
                  extensions=['jinja2.ext.do'])

# Use a practically unique temporary filename, see #314
tmpsuffix = ".tmp." + str(os.getpid())


# Best effort to try to debug as many parameters as easily doable.
def add_debug_to_dict(type, name, dict):
  debug_type_to_when_and_how = {
    "int":           ("before", "%d"),
    "unsigned int":  ("before", "%u"),
    "mode_t":        ("before", "%u"),
    "uid_t":         ("before", "%u"),
    "gid_t":         ("before", "%u"),
    "long":          ("before", "%ld"),
    "ssize_t":       ("before", "%ld"),
    "off_t":         ("before", "%ld"),
    "off64_t":       ("before", "%ld"),
    "unsigned long": ("before", "%lu"),
    "size_t":        ("before", "%lu"),
    "const char *":  ("before", "\\\"%s\\\""),
    "char *":        ("after",  "\\\"%s\\\""),  # assume the call modifies, so log at the end
    "FILE *":        ("before", "%p"),
    "DIR *":         ("before", "%p"),
  }

  if type in debug_type_to_when_and_how:
    (when, fmt) = debug_type_to_when_and_how[type]

    if name == 'ret':
      when = "after"

    dict['debug_' + when + '_fmt'] += ", " + name + "=" + fmt
    dict['debug_' + when + '_args'] += ", " + name


# Split the C parameter specification of a function, at spaces that are outside of parentheses.
# E.g. "int (*compar)(void *, void *), void *arg" -> ["int (*compar)(void *, void *)", "void *arg"]
def split_param_spec(sig):
  sig = sig.strip()
  if not sig:
    return []

  ret = []
  start_pos = 0
  pos = 0
  nest = 0
  while pos <= len(sig):
    if pos == len(sig) or (sig[pos] == ',' and nest == 0):
      ret.append(sig[start_pos:pos].strip())
      start_pos = pos + 1
    elif sig[pos] == '(':
      nest += 1
    elif sig[pos] == ')':
      nest -= 1
    pos += 1
  return ret


# For one parameter specification of a C function, extract the type and the name.
# E.g. "int (*compar)(void *, void *)" -> ("int (*)(void *, void *)", "compar")
def get_type_and_name(sig):
  sig = sig.strip()
  name_end = len(sig)
  # Handle array declaration, e.g. "[2]" in "int pipefd[2]".
  while name_end > 0 and sig[name_end - 1] == ']':
    name_end = sig.rindex('[', 0, name_end)
  # Handle function pointer parameter, e.g. "int (*compar)(void *, void *)".
  # Walk backwards from the end, locate the beginning of the parameter list.
  if name_end > 0 and sig[name_end - 1] == ')':
    pos = name_end - 1
    nest = 1
    while pos > 0 and nest > 0:
      if sig[pos - 1] == ')':
        nest += 1
      elif sig[pos - 1] == '(':
        nest -= 1
      pos -= 1
    # pos now points to the parameter list, e.g. "(void *, void *)". Still need to walk back through a ')'.
    name_end = sig.rindex(')', 0, pos)
  # name_end is now the end of the variable name. Let's find the sequence of alphanumeric + '_' characters.
  name_start = name_end
  while name_start > 0 and (sig[name_start - 1].isalnum() or sig[name_start - 1] == '_'):
      name_start -= 1
  # The variable name is between name_start and name_end, the rest is the signature.
  return (sig[0:name_start].strip() + sig[name_end:].strip(), sig[name_start:name_end].strip())


# Given a method signature (return type, types and names of parameters)
# as strings, generates various values for the convenience of templates.
# Supports arrays, but does not support function pointers.
#
# For the debug info to work, requires a space before the start,
# e.g. "char *" and not "char*".
#
# E.g.
#           rettype = "int"
#               sig = "const char *pathname, int flags, int pipefd[2], ..."
# ->
#             types = ["const char *", "int", "int[2]"]
#             names = ["pathname, "flags", "pipefd"]
#   types_and_names = [("const char *", "pathname"), ("int", "flags"), ("int[2]", "pipefd")]
#            vararg = True
#         types_str = "const char *, int, int[2], ..."
#           sig_str = "const char *pathname, int flags, int pipefd[2], ..."
#         names_str = "pathname, flags, pipefd"
#
#  debug_before_fmt ≈ ", pathname = \"%s\", flags = %d"
# debug_before_args ≈ ", pathname, flags"
#   debug_after_fmt ≈ ", ret = %d"
#  debug_after_args ≈ ", ret"
def add_signature_to_dict(rettype, sig, dict):
  dict['types'] = []
  dict['names'] = []
  dict['types_and_names'] = []
  dict['vararg'] = False
  dict['sig_str'] = sig

  dict['debug_before_fmt'] = ''
  dict['debug_before_args'] = ''
  dict['debug_after_fmt'] = ''
  dict['debug_after_args'] = ''

  params = split_param_spec(sig)
  for type_and_name in params:
    type_and_name = type_and_name.strip()
    if type_and_name == '...':
      dict['vararg'] = True
    else:
      (type, name) = get_type_and_name(type_and_name)
      dict['types'].append(type)
      dict['names'].append(name)
      dict['types_and_names'].append((type, name))

      add_debug_to_dict(type, name, dict)

  dict['types_str'] = ', '.join(dict['types'])
  if dict['vararg']:
    dict['types_str'] += ', ...'
  dict['names_str'] = ', '.join(dict['names'])

  add_debug_to_dict(rettype, 'ret', dict)

  return dict


# Keep track of the functions we've already generated.
generated={}


# Generate stuff for the given libc / kernel method.
#
# Makes sure to exit with an error if there's a skip() or another
# generate() call somewhere else for the same method.
#
# rettype: method's return type, as string
# funcs: one or more function names, as (list of) string
# sig: the function signature, as string
# tpl: the template file to use, default is 'tpl.c'
# msg: the message type, default is the first func
# success: the success condition, default depends on rettype
# dict: further parameters to pass to the template,
#       see the template for their documentation
def generate(rettype, funcs, sig, **dict):
  if type(funcs) == str:
    funcs = [funcs]

  if 'tpl' not in dict:
    dict['tpl'] = 'tpl.c'
  else:
    dict['tpl'] = 'tpl_' + dict['tpl'] + '.c'
  template = env.get_template(dict['tpl'])

  if 'msg' not in dict:
    dict['msg'] = funcs[0]

  if 'success' not in dict:
    if rettype == 'void':
      dict['success'] = "true /* default success condition for void rettype */"
    elif '*' in rettype:
      dict['success'] = "ret != NULL /* default success condition for pointer rettype */"
    else:
      dict['success'] = "ret >= 0 /* default success condition for scalar rettype */"

  add_signature_to_dict(rettype, sig, dict)

  for func in funcs:
    if func in generated:
      print("generate_interceptors: Error: Already generated '" + func + "'", file=sys.stderr)
      exit(1)
    generated[func] = True

    for gen in outputs:
      rendered = template.render(gen=gen, rettype=rettype, func=func, **dict)
      if rendered:
        with open(outdir + "/gen_" + gen + tmpsuffix, "a") as f:
          f.write(rendered)


# Do not intercept the given libc / kernel method.
#
# This does two things:
#
# Creates a "#define IC_ORIG(func) func" redirect so that you can always
# call IC_ORIG(foo)() in the interceptor code, without worrying whether
# that method is overridden or not.
#
# Also makes sure to exit with an error if there's a
# generate() call somewhere else for the same method.
#
# You can pass multiple function names at once.
def skip(*list):
  for func in list:
    generate('', func, '',
             tpl="skip")


# Initialize the output files with their headers.
# Also truncate them before we'll reopen them plenty of times for appending.
for gen in outputs:
  with open(outdir + "/gen_" + gen + tmpsuffix, "w") as f:
    f.write("/* Auto-generated by generate_interceptors, do not edit */\n\n")


# Intercept vararg open() and friends
generate("int", ["open", "open64"], "const char *pathname, int flags, ...",
         tpl="open",
         msg_skip_fields=["pathname"])
generate("int", ["openat", "openat64"], "int dirfd, const char *pathname, int flags, ...",
         tpl="open",
         msg_skip_fields=["pathname"],
         msg="open")

# Intercept open_2 variants
generate("int", ["__open_2", "__open64_2"], "const char *pathname, int flags",
         tpl="open",
         msg_skip_fields=["pathname"],
         msg="open")
generate("int", ["__openat_2", "__openat64_2"], "int dirfd, const char *pathname, int flags",
         tpl="open",
         msg_skip_fields=["pathname"],
         msg="open")

# Intercept creat()
generate("int", ["creat", "creat64"], "const char *pathname, mode_t mode",
         tpl="open",
         before_lines=["const int flags = O_CREAT | O_WRONLY | O_TRUNC;"],
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(open, pathname);",
                         "fbbcomm_builder_open_set_flags(&ic_msg, flags);",
                         "fbbcomm_builder_open_set_pre_open_sent(&ic_msg, pre_open_sent);"],
         msg="open")

# Intercept fopen
# Note: confusingly open()'s and fopen()'s manual uses the word "mode" for something completely different.
generate("FILE *", ["fopen", "fopen64"], "const char *pathname, const char *mode",
         before_lines=["int open_flags = intercept_fopen_mode_to_open_flags_helper(mode);",
                       "int pre_open_sent = i_am_intercepting && maybe_send_pre_open(AT_FDCWD, pathname, open_flags);"],
         after_lines=["int fd = safe_fileno(ret);",
                      "if (i_am_intercepting) clear_notify_on_read_write_state(fd);",
                      "assert(!voidp_set_contains(&popened_streams, ret));"],
         msg="open",
         msg_skip_fields=["pathname", "mode"],
         msg_add_fields=["fbbcomm_builder_open_set_flags(&ic_msg, open_flags);",
                         "if (open_flags & O_CREAT) fbbcomm_builder_open_set_mode(&ic_msg, 0666);",
                         "if (success) fbbcomm_builder_open_set_ret(&ic_msg, fd);",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(open, pathname);",
                         "fbbcomm_builder_open_set_pre_open_sent(&ic_msg, pre_open_sent);"],
         ack_condition="success && !is_path_at_locations(pathname, &system_locations)")

# Intercept freopen
generate("FILE *", ["freopen", "freopen64"], "const char *pathname, const char *mode, FILE *stream",
         before_lines=["int open_flags = intercept_fopen_mode_to_open_flags_helper(mode);",
                       "int pre_open_sent = i_am_intercepting && maybe_send_pre_open(AT_FDCWD, pathname, open_flags);",
                       "int oldfd = safe_fileno(stream);",
                       "if (i_am_intercepting) clear_notify_on_read_write_state(oldfd);"],
         after_lines=["int newfd = safe_fileno(ret);",
                      "if (i_am_intercepting) clear_notify_on_read_write_state(newfd);"],
         msg_skip_fields=["pathname", "mode", "stream"],
         msg_add_fields=["fbbcomm_builder_freopen_set_flags(&ic_msg, intercept_fopen_mode_to_open_flags_helper(mode));",
                         "if (oldfd >= 0) fbbcomm_builder_freopen_set_oldfd(&ic_msg, oldfd);",
                         "if (success) fbbcomm_builder_freopen_set_ret(&ic_msg, newfd);",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(freopen, pathname);",
                         "fbbcomm_builder_freopen_set_pre_open_sent(&ic_msg, pre_open_sent);"],
         ack_condition="success && !is_path_at_locations(pathname, &system_locations)")

# High level stream operation only
generate("FILE *", "fdopen", "int fd, const char *mode",
         msg=None,
         after_lines=["assert(!voidp_set_contains(&popened_streams, ret));"])

# FIXME add support for shm_open
# FIXME shm_open is in librt, ignore for now
#generate("int", "shm_open", "const char *name, int oflag, mode_t mode",
#         tpl="once")
generate("int", "memfd_create", "const char *name, unsigned int flags",
         send_ret_on_success=True,
         send_msg_on_error=False)
generate("int", "timerfd_create", "int clockid, int flags",
         msg_skip_fields=["clockid"],
         send_ret_on_success=True,
         send_msg_on_error=False)
generate("int", "epoll_create", "int size",
         msg_skip_fields=["size"],
         send_ret_on_success=True,
         send_msg_on_error=False)
generate("int", "epoll_create1", "int flags",
         msg="epoll_create",
         send_ret_on_success=True,
         send_msg_on_error=False)
generate("int", "eventfd", "unsigned int initval, int flags",
         msg_skip_fields=["initval"],
         send_ret_on_success=True,
         send_msg_on_error=False)
generate("int", "signalfd", "int fd, const sigset_t *mask, int flags",
         msg_skip_fields=["mask"],
         send_ret_on_success=True,
         send_msg_on_error=False)

# Intercept close and fclose
# Don't call the actual method on the supervisor connection fd.
generate("int", "close", "int fd",
         before_lines=["if (i_am_intercepting) set_notify_on_read_write_state(fd);"])
generate("int", "fclose", "FILE *stream",
         before_lines=["int fd = safe_fileno(stream); /* save it here, we can't do fileno() after the fclose() */",
                       "if (i_am_intercepting) set_notify_on_read_write_state(fd);",
                       "voidp_set_erase(&popened_streams, stream);"],
         send_msg_condition="fd != -1",
         msg="close",
         msg_skip_fields=["stream"],
         msg_add_fields=["fbbcomm_builder_close_set_fd(&ic_msg, fd);"])

# Intercept closefrom and close_range
generate("void", "closefrom", "int lowfd",
         tpl="closefrom",
         send_msg_on_error=False)
# The manpage says "unsigned int flags" but in unistd.h it's "int flags".
generate("int", "close_range", "unsigned int first, unsigned int last, int flags",
         tpl="close_range")

# Unlike fclose(), fcloseall() only closes the high level streams and not the underlying fds.
# So we don't need to notify the supervisor. We need to clear the popened_streams set, though.
generate("int", "fcloseall", "",
         msg=None,
         after_lines=["voidp_set_clear(&popened_streams);"])

# Intercept opendir, closedir (no need to intercept fdopendir)
generate("DIR *", "opendir", "const char *pathname",
         msg="open",
         msg_skip_fields=["pathname"],
         msg_add_fields=["fbbcomm_builder_open_set_flags(&ic_msg, O_RDONLY | O_CLOEXEC | O_DIRECTORY);",
                         "if (success) fbbcomm_builder_open_set_ret(&ic_msg, IC_ORIG(dirfd)(ret));",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(open, pathname);",
                         "fbbcomm_builder_open_set_pre_open_sent(&ic_msg, false);"],
         ack_condition="success && !is_path_at_locations(pathname, &system_locations)")
generate("int", "closedir", "DIR *dirp",
         before_lines=["int fd = safe_dirfd(dirp); /* save it here, we can't do dirfd() after the closedir() */"],
         msg="close",
         msg_skip_fields=["dirp"],
         msg_add_fields=["fbbcomm_builder_close_set_fd(&ic_msg, fd);"])
# FIXME implement scandir(at)(64)

generate("int", "mkdir", "const char *pathname, mode_t mode",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(mkdir, pathname);"])
generate("int", "mkdirat", "int dirfd, const char *pathname, mode_t mode",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(mkdir, dirfd, pathname);"],
         msg="mkdir")

# Intercept the remove, rmdir, unlink families
generate("int", ["unlink", "remove"], "const char *pathname",
         before_lines=["if (i_am_intercepting) {",
                       "  maybe_send_pre_open(AT_FDCWD, pathname, O_WRONLY | O_TRUNC);",
                       "}"],
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(unlink, pathname);"])
generate("int", "unlinkat", "int dirfd, const char *pathname, int flags",
         before_lines=["if (i_am_intercepting) {",
                       "  maybe_send_pre_open(dirfd, pathname, O_WRONLY | O_TRUNC);",
                       "}"],
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(unlink, dirfd, pathname);"],
         msg="unlink")
generate("int", "rmdir", "const char *pathname",
         before_lines=["if (i_am_intercepting) {",
                       "  maybe_send_pre_open(AT_FDCWD, pathname, O_WRONLY | O_TRUNC);",
                       "}"],
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(rmdir, pathname);"])

# Intercept the rename family
generate("int", "rename", "const char *oldpath, const char *newpath",
         before_lines=["if (i_am_intercepting) {",
                       "  maybe_send_pre_open_without_ack_request(AT_FDCWD, oldpath, O_WRONLY | O_TRUNC);",
                       "  maybe_send_pre_open(AT_FDCWD, newpath, O_WRONLY | O_TRUNC);",
                       "}"],
         msg_skip_fields=["oldpath", "newpath"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(rename, oldpath);",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(rename, newpath);"],
         ack_condition="true")
generate("int", "renameat", "int olddirfd, const char *oldpath, int newdirfd, const char *newpath",
         before_lines=["if (i_am_intercepting) {",
                       "  maybe_send_pre_open_without_ack_request(olddirfd, oldpath, O_WRONLY | O_TRUNC);",
                       "  maybe_send_pre_open(newdirfd, newpath, O_WRONLY | O_TRUNC);",
                       "}"],
         msg_skip_fields=["oldpath", "newpath"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(rename, olddirfd, oldpath);",
                         "BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(rename, newdirfd, newpath);"],
         msg="rename",
         ack_condition="true")
generate("int", "renameat2", "int olddirfd, const char *oldpath, int newdirfd, const char *newpath, unsigned int flags",
         before_lines=["if (i_am_intercepting) {",
                       "  maybe_send_pre_open_without_ack_request(olddirfd, oldpath, O_WRONLY | O_TRUNC);",
                       "  maybe_send_pre_open(newdirfd, newpath, O_WRONLY | O_TRUNC);",
                       "}"],
         msg_skip_fields=["oldpath", "newpath"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(rename, olddirfd, oldpath);",
                         "BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(rename, newdirfd, newpath);"],
         msg="rename",
         ack_condition="true")

# Intercept operations that read from a file descriptor.
# FIXME also intercept mmap with PROT_READ
generate("ssize_t", "read", "int fd, void *buf, size_t count",
         tpl="read",
         msg_skip_fields=["buf", "count"],
         ack_condition="true")
generate("ssize_t", "__read_chk", "int fd, void *buf, size_t count, size_t fortify_size",
         tpl="read",
         msg_skip_fields=["buf", "count", "fortify_size"],
         ack_condition="true")
generate("ssize_t", "readv", "int fd, const struct iovec *iov, int iovcnt",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt"],
         ack_condition="true")
generate("ssize_t", "pread", "int fd, void *buf, size_t count, off_t offset",
         tpl="read",
         msg_skip_fields=["buf", "count", "offset"],
         ack_condition="true")
generate("ssize_t", "__pread_chk", "int fd, void *buf, size_t count, off_t offset, size_t fortify_size",
         tpl="read",
         msg_skip_fields=["buf", "count", "offset", "fortify_size"],
         ack_condition="true")
generate("ssize_t", "pread64", "int fd, void *buf, size_t count, off64_t offset",
         tpl="read",
         msg_skip_fields=["buf", "count", "offset"],
         ack_condition="true")
generate("ssize_t", "__pread64_chk", "int fd, void *buf, size_t count, off64_t offset, size_t fortify_size",
         tpl="read",
         msg_skip_fields=["buf", "count", "offset", "fortify_size"],
         ack_condition="true")
generate("ssize_t", "preadv", "int fd, const struct iovec *iov, int iovcnt, off_t offset",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt", "offset"],
         ack_condition="true")
generate("ssize_t", "preadv64", "int fd, const struct iovec *iov, int iovcnt, off64_t offset",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt", "offset"],
         ack_condition="true")
generate("ssize_t", "preadv2", "int fd, const struct iovec *iov, int iovcnt, off_t offset, int flags",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt", "offset", "flags"],
         ack_condition="true")
generate("ssize_t", "preadv64v2", "int fd, const struct iovec *iov, int iovcnt, off64_t offset, int flags",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt", "offset", "flags"],
         ack_condition="true")
generate("size_t", ["fread", "fread_unlocked"], "void *ptr, size_t size, size_t nmemb, FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         success="ret > 0 || !ferror(stream)",
         msg_skip_fields=["ptr", "size", "nmemb", "stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("size_t", ["__fread_chk", "__fread_unlocked_chk"], "void *ptr, size_t fortify_size, size_t size, size_t nmemb, FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         success="ret > 0 || !ferror(stream)",
         msg_skip_fields=["ptr", "fortify_size", "size", "nmemb", "stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("int", ["fgetc", "fgetc_unlocked", "getc", "getc_unlocked", "getw"], "FILE *stream",
         tpl="read",
         success="ret != EOF || !ferror(stream)",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("wint_t", ["fgetwc", "fgetwc_unlocked", "getwc", "getwc_unlocked"], "FILE *stream",
         tpl="read",
         success="ret != WEOF || !ferror(stream)",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("char *", ["fgets", "fgets_unlocked"], "char *s, int size, FILE *stream",
         tpl="read",
         success="ret != NULL || !ferror(stream)",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["s", "size", "stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("char *", ["__fgets_chk", "__fgets_unlocked_chk"], "char *s, size_t fortify_size, int size, FILE *stream",
         success="ret != NULL || !ferror(stream)",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["s", "fortify_size", "size", "stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("wchar_t *", ["fgetws", "fgetws_unlocked"], "wchar_t *s, int size, FILE *stream",
         tpl="read",
         success="ret != NULL || !ferror(stream)",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["s", "size", "stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("wchar_t *", ["__fgetws_chk", "__fgetws_unlocked_chk"], "wchar_t *s, size_t fortify_size, int size, FILE *stream",
         success="ret != NULL || !ferror(stream)",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["s", "fortify_size", "size", "stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("int", ["getchar", "getchar_unlocked"], "",
         tpl="read",
         success="ret != EOF || !ferror(stdin)",
         before_lines=["int fd = safe_fileno(stdin);"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("wint_t", ["getwchar", "getwchar_unlocked"], "",
         tpl="read",
         success="ret != WEOF || !ferror(stdin)",
         before_lines=["int fd = safe_fileno(stdin);"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("char *", "gets", "char *s",  # should be never used, see man gets
         tpl="read",
         success="ret != NULL || !ferror(stdin)",
         before_lines=["int fd = safe_fileno(stdin);"],
         msg_skip_fields=["s"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("char *", "__gets_chk", "char *s, size_t fortify_size",  # should be never used, see man gets
         tpl="read",
         success="ret != NULL || !ferror(stdin)",
         before_lines=["int fd = safe_fileno(stdin);"],
         msg_skip_fields=["s", "fortify_size"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("FB_SSIZE_T", "getline", "char **lineptr, size_t *n, FILE *stream",
         tpl="read",
         success="ret != EOF || !ferror(stream)",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["lineptr", "n", "stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("FB_SSIZE_T", ["getdelim", "__getdelim"], "char **lineptr, size_t *n, int delim, FILE *stream",
         tpl="read",
         success="ret != EOF || !ferror(stream)",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["lineptr", "n", "delim", "stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
# glibc magic, see #343
generate("int", ["__uflow", "__underflow"], "FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         success="true",
         msg_skip_fields=["stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("wint_t", ["__wuflow", "__wunderflow"], "FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         success="true",
         msg_skip_fields=["stream"],
         msg_add_fields=["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
# Handle (__isoc99_)?v?f?w?scanf
for i in ['', '__isoc99_']:
  for v in ['', 'v']:
    for f in ['', 'f']:
      for w in ['', 'w']:
        func = i + v + f + w + "scanf"
        if f == '':
          sig_str = ''
          names_str = ''
          stream="stdin"
          before_lines = ["int fd = safe_fileno(stdin);"]
          msg_skip_fields = []
          msg_add_fields = ["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"]
        elif f == 'f':
          sig_str = "FILE *stream, "
          names_str = "stream, "
          stream="stream"
          before_lines = ["int fd = safe_fileno(stream);"]
          send_msg_condition="fd != -1",
          msg_skip_fields = ["stream"]
          msg_add_fields = ["fbbcomm_builder_read_from_inherited_set_fd(&ic_msg, fd);"]
        if w:
          sig_str += "const wchar_t *format, "
          success="(unsigned int) ret != WEOF || !ferror(" + stream + ")"
        else:
          sig_str += "const char *format, "
          success="ret != EOF || !ferror(" + stream + ")"
        names_str += "format, "
        msg_skip_fields += ["format"]
        if v:
          sig_str += "FB_VA_LIST ap"
          call_orig_lines = None
          msg_skip_fields += ["ap"]
        else:
          sig_str += "..."
          call_orig_lines = ["ret = IC_ORIG(" + i + "v" + f + w + "scanf)(" + names_str + "ap);"]
        generate("int", func, sig_str,
                 tpl="read",
                 success=success,
                 before_lines=before_lines,
                 call_orig_lines=call_orig_lines,
                 msg_skip_fields=msg_skip_fields,
                 msg_add_fields=msg_add_fields,
                 ack_condition="true")
for i in ['', '__isoc99_']:
  for v in ['', 'v']:
    for w in ['', 'w']:
      skip(i + v + "s" + w + "scanf")

# Intercept operations that write to a file descriptor.
# FIXME also intercept mmap with PROT_WRITE
generate("ssize_t", "write", "int fd, const void *buf, size_t count",
         tpl="write",
         msg_skip_fields=["buf", "count"],
         ack_condition="true")
generate("ssize_t", "writev", "int fd, const struct iovec *iov, int iovcnt",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt"],
         ack_condition="true")
generate("ssize_t", "pwrite", "int fd, const void *buf, size_t count, off_t offset",
         tpl="write",
         msg_skip_fields=["buf", "count", "offset"],
         ack_condition="true")
generate("ssize_t", "pwrite64", "int fd, const void *buf, size_t count, off64_t offset",
         tpl="write",
         msg_skip_fields=["buf", "count", "offset"],
         ack_condition="true")
generate("ssize_t", "pwritev", "int fd, const struct iovec *iov, int iovcnt, off_t offset",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt", "offset"],
         ack_condition="true")
generate("ssize_t", "pwritev64", "int fd, const struct iovec *iov, int iovcnt, off64_t offset",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt", "offset"],
         ack_condition="true")
generate("ssize_t", "pwritev2", "int fd, const struct iovec *iov, int iovcnt, off_t offset, int flags",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt", "offset", "flags"],
         ack_condition="true")
generate("ssize_t", "pwritev64v2", "int fd, const struct iovec *iov, int iovcnt, off64_t offset, int flags",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt", "offset", "flags"],
         ack_condition="true")
generate("size_t", ["fwrite", "fwrite_unlocked"], "const void *ptr, size_t size, size_t nmemb, FILE *stream",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         success="ret > 0 || !ferror(stream)",
         msg_skip_fields=["ptr", "size", "nmemb", "stream"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("int", ["fputc", "fputc_unlocked", "putc", "putc_unlocked", "putw"], "int c, FILE *stream",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["c", "stream"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("wint_t", ["fputwc", "fputwc_unlocked", "putwc", "putwc_unlocked"], "wchar_t wc, FILE *stream",
         tpl="write",
         success="ret != WEOF",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["wc", "stream"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("int", ["fputs", "fputs_unlocked"], "const char *s, FILE *stream",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["s", "stream"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("int", ["fputws", "fputws_unlocked"], "const wchar_t *s, FILE *stream",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         msg_skip_fields=["s", "stream"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("int", ["putchar", "putchar_unlocked"], "int c",
         tpl="write",
         before_lines=["int fd = safe_fileno(stdout);"],
         msg_skip_fields=["c"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("wint_t", ["putwchar", "putwchar_unlocked"], "wchar_t wc",
         tpl="write",
         success="ret != WEOF",
         before_lines=["int fd = safe_fileno(stdout);"],
         msg_skip_fields=["wc"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("int", "puts", "const char *s",
         tpl="write",
         before_lines=["int fd = safe_fileno(stdout);"],
         msg_skip_fields=["s"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
# glibc magic, see #343
generate("int", "__overflow", "FILE *stream, int ch",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         success="true",
         msg_skip_fields=["stream", "ch"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("wint_t", "__woverflow", "FILE *stream, wint_t ch",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         send_msg_condition="fd != -1",
         success="true",
         msg_skip_fields=["stream", "ch"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
# There's no public verror() and verror_at_line().
# Construct the message ourselves so that we don't have to rely on
# gcc's __builtin_apply() with its arbitrarily guessed size parameter.
generate("void", "error", "int status, int errnum, const char *format, ...",
         tpl="error",
         before_lines=["int fd = safe_fileno(stderr);"],
         call_orig_lines=["int msglen = vsnprintf(NULL, 0, format, ap);",
                          "va_end(ap);",
                          "char msgbuf[msglen + 1];",
                          "va_start(ap, format);",
                          "vsnprintf(msgbuf, msglen + 1, format, ap);",
                          "IC_ORIG(error)(status, errnum, \"%s\", msgbuf);"],
         msg_skip_fields=["status", "errnum", "format"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("void", "error_at_line", "int status, int errnum, const char *filename, unsigned int linenum, const char *format, ...",
         tpl="error",
         before_lines=["int fd = safe_fileno(stderr);"],
         call_orig_lines=["int msglen = vsnprintf(NULL, 0, format, ap);",
                          "va_end(ap);",
                          "char msgbuf[msglen + 1];",
                          "va_start(ap, format);",
                          "vsnprintf(msgbuf, msglen + 1, format, ap);",
                          "IC_ORIG(error_at_line)(status, errnum, filename, linenum, \"%s\", msgbuf);"],
         msg_skip_fields=["status", "errnum", "filename", "linenum", "format"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
generate("void", ["herror", "perror"], "const char *s",
         tpl="write",
         before_lines=["int fd = safe_fileno(stderr);"],
         msg_skip_fields=["s"],
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
# Handle v?(err|warn)x?
for v in ['', 'v']:
  for e in ['err', 'warn']:
    for x in ['', 'x']:
      func = v + e + x
      if e == 'err':
        sig_str = "int status, "
        names_str = "status, "
        tpl = "error"
        msg_skip_fields = ["status"]
      else:
        sig_str = ''
        names_str = ''
        tpl = "write"
        msg_skip_fields = []
      sig_str += "const char *format, "
      names_str += "format, "
      msg_skip_fields += ["format"]
      if v:
        sig_str += "va_list ap"
        call_orig_lines = None
        msg_skip_fields += ["ap"]
      else:
        sig_str += "..."
        call_orig_lines = ["IC_ORIG(v" + e + x + ")(" + names_str + "ap);"]
      generate("void", func, sig_str,
         tpl=tpl,
         before_lines=["int fd = safe_fileno(stderr);"],
         call_orig_lines=call_orig_lines,
         msg_skip_fields=msg_skip_fields,
         msg_add_fields=["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"],
         ack_condition="true")
# Handle (__)?v?[fd]?w?printf(_chk)?
for v in ['', 'v']:
  for f in ['', 'f', 'd']:
    for w in ['', 'w']:
      for (c1, c2) in [('', ''), ('__', '_chk')]:
        if f == 'd' and w == 'w':
          # No [v]dwprintf() in glibc
          continue
        func = c1 + v + f + w + "printf" + c2
        if f == '':
          sig_str = ''
          names_str = ''
          before_lines = ["int fd = safe_fileno(stdout);"]
          msg_skip_fields = []
          msg_add_fields = ["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"]
        elif f == 'f':
          sig_str = "FILE *stream, "
          names_str = "stream, "
          before_lines = ["int fd = safe_fileno(stream);"]
          send_msg_condition="fd != -1",
          msg_skip_fields = ["stream"]
          msg_add_fields = ["fbbcomm_builder_write_to_inherited_set_fd(&ic_msg, fd);"]
        elif f == 'd':
          sig_str = "int fd, "
          names_str = "fd, "
          before_lines = []
          msg_skip_fields = []
          msg_add_fields = []
        if c1:
          sig_str += "int fortify_flag, "
          names_str += "fortify_flag, "
          msg_skip_fields += ["fortify_flag"]
        if w:
          sig_str += "const wchar_t *format, "
        else:
          sig_str += "const char *format, "
        names_str += "format, "
        msg_skip_fields += ["format"]
        if v:
          sig_str += "FB_VA_LIST ap"
          call_orig_lines = None
          msg_skip_fields += ["ap"]
        else:
          sig_str += "..."
          call_orig_lines = ["ret = IC_ORIG(" + c1 + "v" + f + w + "printf" + c2 + ")(" + names_str + "ap);"]
        generate("int", func, sig_str,
                 tpl="write",
                 before_lines=before_lines,
                 call_orig_lines=call_orig_lines,
                 msg_skip_fields=msg_skip_fields,
                 msg_add_fields=msg_add_fields,
                 ack_condition="true")
for v in ['', 'v']:
  for w in ['', 'w', 'n']:
    for (c1, c2) in [('', ''), ('__', '_chk')]:
      skip(c1 + v + "s" + w + "printf" + c2)
for v in ['', 'v']:
  for (c1, c2) in [('', ''), ('__', '_chk')]:
    skip(c1 + v + "asprintf" + c2)

# Intercept chdir and fchdir
generate("int", "chdir", "const char *pathname",
         msg_skip_fields=["pathname"],
         # Don't make pathname absolute, since the macro would calculate it after calling chdir
         msg_add_fields=["BUILDER_SET_CANONICAL(chdir, pathname);",
                         "if (success) {",
                         "  char* getcwd_ret = IC_ORIG(getcwd)(ic_cwd, IC_PATH_BUFSIZE);",
                         "  (void) getcwd_ret;",
                         "  ic_cwd_len = strlen(ic_cwd);",
                         "}"])
generate("int", "fchdir", "int fd",
         after_lines=["if (success) {",
                      "  char* getcwd_ret = IC_ORIG(getcwd)(ic_cwd, IC_PATH_BUFSIZE);",
                      "  (void) getcwd_ret;",
                      "  ic_cwd_len = strlen(ic_cwd);",
                      "}"])

# Intercept the chmod family
generate("int", "chmod", "const char *pathname, mode_t mode",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(chmod, pathname);"])
generate("int", "lchmod", "const char *pathname, mode_t mode",
         msg="chmod",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(chmod, pathname);",
                         "fbbcomm_builder_chmod_set_flags(&ic_msg, AT_SYMLINK_NOFOLLOW);"])
generate("int", "fchmodat", "int dirfd, const char *pathname, mode_t mode, int flags",
         msg="chmod",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(chmod, dirfd, pathname);"])
generate("int", "fchmod", "int fd, mode_t mode")

# Intercept the chown family
generate("int", "chown", "const char *pathname, uid_t owner, gid_t group",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(chown, pathname);"])
generate("int", "lchown", "const char *pathname, uid_t owner, gid_t group",
         msg="chown",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(chown, pathname);",
                         "fbbcomm_builder_chown_set_flags(&ic_msg, AT_SYMLINK_NOFOLLOW);"])
generate("int", "fchownat", "int dirfd, const char *pathname, uid_t owner, gid_t group, int flags",
         msg="chown",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(chown, dirfd, pathname);"])
generate("int", "fchown", "int fd, uid_t owner, gid_t group")

# Intercept the link, symlink and readlink families
generate("int", "link", "const char *oldpath, const char *newpath",
         msg_skip_fields = ["oldpath", "newpath"],
         msg_add_fields = ["BUILDER_SET_ABSOLUTE_CANONICAL(link, oldpath);",
                           "BUILDER_SET_ABSOLUTE_CANONICAL(link, newpath);"])
generate("int", "linkat", "int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags",
         msg_skip_fields = ["oldpath", "newpath"],
         msg_add_fields = ["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(link, olddirfd, oldpath);",
                           "BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(link, newdirfd, newpath);"],
         msg="link")
generate("int", "symlink", "const char *target, const char *newpath",
         msg_skip_fields = ["newpath"],
         msg_add_fields = ["BUILDER_SET_ABSOLUTE_CANONICAL(symlink, newpath);"])
generate("int", "symlinkat", "const char *target, int newdirfd, const char *newpath",
         msg_skip_fields = ["newpath"],
         msg_add_fields = ["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(symlink, newdirfd, newpath);"],
         msg="symlink")

generate("ssize_t", "readlink", "const char *pathname, char *buf, size_t bufsiz",
         tpl="readlink",
         msg_skip_fields=["pathname", "buf"],
         msg_add_fields = ["BUILDER_SET_ABSOLUTE_CANONICAL(readlink, pathname);"])
generate("ssize_t", "__readlink_chk", "const char *pathname, char *buf, size_t bufsiz, size_t fortify_size",
         tpl="readlink",
         msg="readlink",
         msg_skip_fields=["pathname", "buf", "fortify_size"],
         msg_add_fields = ["BUILDER_SET_ABSOLUTE_CANONICAL(readlink, pathname);"])
generate("ssize_t", "readlinkat", "int dirfd, const char *pathname, char *buf, size_t bufsiz",
         tpl="readlink",
         msg="readlink",
         msg_skip_fields=["pathname", "buf"],
         msg_add_fields = ["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(readlink, dirfd, pathname);"])
generate("ssize_t", "__readlinkat_chk", "int dirfd, const char *pathname, char *buf, size_t bufsiz, size_t fortify_size",
         tpl="readlink",
         msg="readlink",
         msg_skip_fields=["pathname", "buf", "fortify_size"],
         msg_add_fields = ["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(readlink, dirfd, pathname);"])
# FIXME realpath

# Intercept the stat family
# mysterious hacks prior to glibc 2.33
generate("int", "__xstat", "int ver, const char *pathname, struct stat *stat_buf",
         msg="stat",
         msg_skip_fields=["ver", "pathname", "stat_buf"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(stat, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "__xstat64", "int ver, const char *pathname, struct stat64 *stat_buf",
         msg="stat",
         msg_skip_fields=["ver", "pathname", "stat_buf"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(stat, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "__lxstat", "int ver, const char *pathname, struct stat *stat_buf",
         msg="stat",
         msg_skip_fields=["ver", "pathname", "stat_buf"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(stat, pathname);",
                         "fbbcomm_builder_stat_set_flags(&ic_msg, AT_SYMLINK_NOFOLLOW);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "__lxstat64", "int ver, const char *pathname, struct stat64 *stat_buf",
         msg="stat",
         msg_skip_fields=["ver", "pathname", "stat_buf"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(stat, pathname);",
                         "fbbcomm_builder_stat_set_flags(&ic_msg, AT_SYMLINK_NOFOLLOW);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "__fxstat", "int ver, int fd, struct stat *stat_buf",
         msg="fstat",
         msg_skip_fields=["ver", "stat_buf"],
         msg_add_fields=["if (success) {",
                         "  fbbcomm_builder_fstat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_fstat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "__fxstat64", "int ver, int fd, struct stat64 *stat_buf",
         msg="fstat",
         msg_skip_fields=["ver", "stat_buf"],
         msg_add_fields=["if (success) {",
                         "  fbbcomm_builder_fstat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_fstat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "__fxstatat", "int ver, int dirfd, const char *pathname, struct stat *stat_buf, int flags",
         msg="stat",
         msg_skip_fields=["ver", "pathname", "stat_buf"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(stat, dirfd, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "__fxstatat64", "int ver, int dirfd, const char *pathname, struct stat64 *stat_buf, int flags",
         msg="stat",
         msg_skip_fields=["ver", "pathname", "stat_buf"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(stat, dirfd, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
# cleaned up beginning with glibc 2.33
generate("int", "stat", "const char *pathname, struct stat *stat_buf",
         msg="stat",
         msg_skip_fields=["pathname", "stat_buf"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(stat, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "stat64", "const char *pathname, struct stat64 *stat_buf",
         msg="stat",
         msg_skip_fields=["pathname", "stat_buf"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(stat, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "lstat", "const char *pathname, struct stat *stat_buf",
         msg="stat",
         msg_skip_fields=["pathname", "stat_buf"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(stat, pathname);",
                         "fbbcomm_builder_stat_set_flags(&ic_msg, AT_SYMLINK_NOFOLLOW);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "lstat64", "const char *pathname, struct stat64 *stat_buf",
         msg="stat",
         msg_skip_fields=["pathname", "stat_buf"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(stat, pathname);",
                         "fbbcomm_builder_stat_set_flags(&ic_msg, AT_SYMLINK_NOFOLLOW);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "fstat", "int fd, struct stat *stat_buf",
         msg="fstat",
         msg_skip_fields=["stat_buf"],
         msg_add_fields=["if (success) {",
                         "  fbbcomm_builder_fstat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_fstat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "fstat64", "int fd, struct stat64 *stat_buf",
         msg="fstat",
         msg_skip_fields=["stat_buf"],
         msg_add_fields=["if (success) {",
                         "  fbbcomm_builder_fstat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_fstat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "fstatat", "int dirfd, const char *pathname, struct stat *stat_buf, int flags",
         msg="stat",
         msg_skip_fields=["pathname", "stat_buf"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(stat, dirfd, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
generate("int", "fstatat64", "int dirfd, const char *pathname, struct stat64 *stat_buf, int flags",
         msg="stat",
         msg_skip_fields=["pathname", "stat_buf"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(stat, dirfd, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, stat_buf->st_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, stat_buf->st_size);",
                         "}"])
# since glibc 2.28
generate("int", "statx", "int dirfd, const char *pathname, int flags, unsigned int mask, struct statx *statx_buf",
         # TODO(rbalint) have separate statx() message with mask also sent
         msg="stat",
         # Always query type and mode to let the supervisor have valid stx_mode
         before_lines=["mask |= STATX_TYPE | STATX_MODE | STATX_SIZE;"],
         msg_skip_fields=["pathname", "mask", "statx_buf"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(stat, dirfd, pathname);",
                         "if (success) {",
                         "  fbbcomm_builder_stat_set_st_mode(&ic_msg, statx_buf->stx_mode);",
                         "  fbbcomm_builder_stat_set_st_size(&ic_msg, statx_buf->stx_size);",
                         # TODO(rbalint) handle when type and mode are not returned (e.g. because they are not requested by the intercepted application, just by the interceptor modifying the mask)
                         "}"])
# Treat isfdtype() as a fstat()
generate("int", "isfdtype", "int fd, int fdtype",
         msg="fstat",
         msg_skip_fields=["fdtype"])

# Disable shortcutting on the statfs family
generate("int", "ustat", "dev_t dev, struct ustat *ubuf",
         tpl="once")
generate("int", "statfs", "const char *path, struct statfs *buf",
         tpl="once")
generate("int", "statfs64", "const char *path, struct statfs64 *buf",
         tpl="once")
generate("int", "fstatfs", "int fd, struct statfs *buf",
         tpl="once")
generate("int", "fstatfs64", "int fd, struct statfs64 *buf",
         tpl="once")
generate("int", "statvfs", "const char *path, struct statvfs *buf",
         tpl="once")
generate("int", "statvfs64", "const char *path, struct statvfs64 *buf",
         tpl="once")
generate("int", "fstatvfs", "int fd, struct statvfs *buf",
         tpl="once")
generate("int", "fstatvfs64", "int fd, struct statvfs64 *buf",
         tpl="once")

# Intercept lockf */
generate("int", "lockf", "int fd, int cmd, off_t len")
generate("int", "lockf64", "int fd, int cmd, off64_t len",
         msg="lockf")

# Intercept fcntl and fcntl64
# The return value is selectively set from tpl_fcntl.c for certain commands.
generate("int", ["fcntl", "fcntl64"], "int fd, int cmd, ...",
         tpl="fcntl")

# Intercept ioctl
generate("int", "ioctl", "int fd, unsigned long cmd, ...",
         tpl="ioctl",
         send_ret_on_success=True)

# Intercept the dup family
generate("int", "dup", "int oldfd",
         after_lines=["copy_notify_on_read_write_state(ret, oldfd);"],
         send_ret_on_success=True)
generate("int", "dup2", "int oldfd, int newfd",
         tpl="dup2",
         msg="dup3")
generate("int", "dup3", "int oldfd, int newfd, int flags",
         tpl="dup2",
         msg="dup3")

# Intercept access variants
generate("int", "access", "const char *pathname, int mode",
         msg="faccessat",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(faccessat, pathname);"])
generate("int", ["euidaccess", "eaccess"], "const char *pathname, int mode",
         msg="faccessat",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(faccessat, pathname);",
                         "fbbcomm_builder_faccessat_set_flags(&ic_msg, AT_EACCESS);"])
generate("int", "faccessat", "int dirfd, const char *pathname, int mode, int flags",
         msg_skip_fields=["pathname"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(faccessat, dirfd, pathname);"])

# Intercept the (l)utime family
generate("int", "utime", "const char *pathname, const struct utimbuf *times",
         msg_skip_fields=["pathname", "times"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(utime, pathname);",
                         "fbbcomm_builder_utime_set_all_utime_now(&ic_msg, times == NULL);"])
generate("int", "utimes", "const char *pathname, const struct timeval times[2]",
         msg="utime",
         msg_skip_fields=["pathname", "times"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(utime, pathname);",
                         "fbbcomm_builder_utime_set_all_utime_now(&ic_msg, times == NULL);"])
generate("int", "lutimes", "const char *pathname, const struct timeval times[2]",
         msg="utime",
         msg_skip_fields=["pathname", "times"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(utime, pathname);",
                         "fbbcomm_builder_utime_set_all_utime_now(&ic_msg, times == NULL);",
                         "fbbcomm_builder_utime_set_flags(&ic_msg, AT_SYMLINK_NOFOLLOW);"])
generate("int", "utimensat", "int dirfd, const char *pathname, const struct timespec times[2], int flags",
         msg="utime",
         msg_skip_fields=["pathname", "times"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(utime, dirfd, pathname);",
                         "fbbcomm_builder_utime_set_all_utime_now(&ic_msg, times == NULL || (times[0].tv_nsec == UTIME_NOW && times[1].tv_nsec == UTIME_NOW));"])
generate("int", "futimesat", "int dirfd, const char *pathname, const struct timeval times[2]",
         msg="utime",
         msg_skip_fields=["pathname", "times"],
         msg_add_fields=["BUILDER_MAYBE_SET_ABSOLUTE_CANONICAL(utime, dirfd, pathname);",
                         "fbbcomm_builder_utime_set_all_utime_now(&ic_msg, times == NULL);"])

# Intercept the futime family
generate("int", "futimes", "int fd, const struct timeval times[2]",
         msg="futime",
         msg_skip_fields=["times"],
         msg_add_fields=["fbbcomm_builder_futime_set_all_utime_now(&ic_msg, times == NULL);"])
generate("int", "futimens", "int fd, const struct timespec times[2]",
         msg="futime",
         msg_skip_fields=["times"],
         msg_add_fields=["fbbcomm_builder_futime_set_all_utime_now(&ic_msg, times == NULL || (times[0].tv_nsec == UTIME_NOW && times[1].tv_nsec == UTIME_NOW));"])

# Intercept dlopen
# The new library's constructor may generate intercepted calls.
# Also note that dlopen() does not set errno, and we always want to notify the supervisor,
# in send_msg_condition we have to skip the default exception on EINTR and EFAULT.
generate("void *", "dlopen", "const char *filename, int flag",
         tpl="dlopen",
         before_lines=["thread_intercept_on = NULL;"],
         after_lines=["thread_intercept_on = \"dlopen\";"],
         send_msg_condition="true",
         msg_skip_fields=["error_no"])
generate("void *", "dlmopen", "Lmid_t lmid, const char *filename, int flag",
         tpl="dlopen",
         msg="dlopen",
         before_lines=["thread_intercept_on = NULL;"],
         after_lines=["thread_intercept_on = \"dlmopen\";"],
         send_msg_condition="true",
         msg_skip_fields=["lmid", "error_no"])

# Intercept the pipe family
generate("int", "pipe", "int pipefd[2]",
         tpl="pipe",
         before_lines=["int flags = 0;"],
         after_lines=["if (success && i_am_intercepting) { clear_notify_on_read_write_state(pipefd[0]); clear_notify_on_read_write_state(pipefd[1]); }"],
         msg_skip_fields=["pipefd"],
         msg_add_fields=["if (success) {",
                         "  fbbcomm_builder_pipe_fds_set_fd0(&ic_msg, pipefd[0]);",
                         "  fbbcomm_builder_pipe_fds_set_fd1(&ic_msg, pipefd[1]);",
                         "}"])
generate("int", "pipe2", "int pipefd[2], int flags",
         tpl="pipe",
         after_lines=["if (success && i_am_intercepting) { clear_notify_on_read_write_state(pipefd[0]); clear_notify_on_read_write_state(pipefd[1]); }"],
         msg_skip_fields=["pipefd"],
         msg_add_fields=["if (success) {",
                         "  fbbcomm_builder_pipe_fds_set_fd0(&ic_msg, pipefd[0]);",
                         "  fbbcomm_builder_pipe_fds_set_fd1(&ic_msg, pipefd[1]);",
                         "}"])

# Intercept the truncate family
generate("int", "truncate", "const char *pathname, off_t len",
         msg_skip_fields=["path"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(truncate, pathname);"])
generate("int", "truncate64", "const char *pathname, off64_t len",
         msg="truncate",
         msg_skip_fields=["path"],
         msg_add_fields=["BUILDER_SET_ABSOLUTE_CANONICAL(truncate, pathname);"])
generate("int", "ftruncate", "int fd, off_t len")
generate("int", "ftruncate64", "int fd, off64_t len",
         msg="ftruncate")

# Intercept the mkstemp family
# Note: these update the pathname template in place.
generate("int", "mkstemp", "char *pathname",
         send_msg_on_error=False,
         msg="open",
         msg_skip_fields=["path"],
         msg_add_fields=["fbbcomm_builder_open_set_flags(&ic_msg, O_RDWR | O_CREAT | O_EXCL);",
                         "fbbcomm_builder_open_set_mode(&ic_msg, 0600);",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(open, pathname);",
                         "fbbcomm_builder_open_set_pre_open_sent(&ic_msg, false);"],
         send_ret_on_success=True,
         ack_condition="true")
generate("int", "mkostemp", "char *pathname, int flags",
         send_msg_on_error=False,
         msg="open",
         msg_skip_fields=["pathname", "flags"],
         msg_add_fields=["fbbcomm_builder_open_set_flags(&ic_msg, O_RDWR | O_CREAT | O_EXCL | (flags & (O_APPEND | O_CLOEXEC | O_SYNC)));",
                         "fbbcomm_builder_open_set_mode(&ic_msg, 0600);",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(open, pathname);",
                         "fbbcomm_builder_open_set_pre_open_sent(&ic_msg, false);"],
         send_ret_on_success=True,
         ack_condition="true")
generate("int", "mkstemps", "char *pathname, int suffixlen",
         send_msg_on_error=False,
         msg="open",
         msg_skip_fields=["pathname", "suffixlen"],
         msg_add_fields=["fbbcomm_builder_open_set_flags(&ic_msg, O_RDWR | O_CREAT | O_EXCL);",
                         "fbbcomm_builder_open_set_mode(&ic_msg, 0600);",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(open, pathname);",
                         "fbbcomm_builder_open_set_pre_open_sent(&ic_msg, false);"],
         send_ret_on_success=True,
         ack_condition="true")
generate("int", "mkostemps", "char *pathname, int suffixlen, int flags",
         send_msg_on_error=False,
         msg="open",
         msg_skip_fields=["pathname", "suffixlen", "flags"],
         msg_add_fields=["fbbcomm_builder_open_set_flags(&ic_msg, O_RDWR | O_CREAT | O_EXCL | (flags & (O_APPEND | O_CLOEXEC | O_SYNC)));",
                         "fbbcomm_builder_open_set_mode(&ic_msg, 0600);",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(open, pathname);",
                         "fbbcomm_builder_open_set_pre_open_sent(&ic_msg, false);"],
         send_ret_on_success=True,
         ack_condition="true")
generate("char *", "mkdtemp", "char *pathname",
         send_msg_on_error=False,
         msg="mkdir",
         msg_skip_fields=["pathname"],
         msg_add_fields=["fbbcomm_builder_mkdir_set_mode(&ic_msg, 0700);",
                         "BUILDER_SET_ABSOLUTE_CANONICAL(mkdir, pathname);"],
         ack_condition="true")
# FIXME needs support on the supervisor for starting to track an fd without knowing the backing file
generate("FILE *", ["tmpfile", "tmpfile64"], "",
         tpl="once")
# "Never use these functions"
# FIXME Supporting them would require supervisor work, or two messages (exclusive open, then close)
generate("char *", ["mktemp", "tmpnam", "tmpnam_r"], "char *tmplt",
         tpl="once",
         diagnostic_ignored = ["-Warray-parameter="],)
generate("char *", ["tempnam"], "const char *dir, const char *pfx",
         tpl="once")

# Disable shortcutting on chroot
generate("int", "chroot", "const char *path",
         tpl="once")

# Skip bridge between low and high level io
skip("fileno", "dirfd")

# Skip directory reading
skip("readdir", "readdir64", "readdir_r", "readdir64_r", "rewinddir", "seekdir", "telldir")
skip("getdents", "getdents64", "getdirentries", "getdirentries64")
# FIXME implement scandir(at)(64)

# Disable shortcutting on mknod
# mysterious hacks prior to glibc 2.33 (also note the pointer "dev_t *")
generate("int", "__xmknod", "int ver, const char *path, mode_t mode, dev_t *dev",
         tpl="once")
generate("int", "__xmknodat", "int ver, int dirfd, const char *path, mode_t mode, dev_t *dev",
         tpl="once")
# cleaned up beginning with glibc 2.33
generate("int", "mknod", "const char *path, mode_t mode, dev_t dev",
         tpl="once")
generate("int", "mknodat", "int dirfd, const char *path, mode_t mode, dev_t dev",
         tpl="once")

# Disable shortcutting on mkfifo
generate("int", "mkfifo", "const char *pathname, mode_t mode",
         tpl="once")
generate("int", "mkfifoat", "int dirfd, const char *pathname, mode_t mode",
         tpl="once")

# Intercept the exit family.
# - _exit() and _Exit() terminate the process immediately, no exit handlers are run.
#   So we need to modify the supervisor about the exit code and resource usage before execuing it.
# - exit() calls the atexit() / on_exit() handlers first. We'll notify the supervisor using the
#   hopefully last on_exit() handler, which is our on_exit_handler() method.
# - quick_exit() calls the at_quick_exit() handlers, which, similarly to the atexit() handlers,
#   do not receive the exit status. So notify the supervisor before calling this method, just like
#   for _exit().
generate("void", ["exit"], "int status",
         tpl="exit",
         no_saved_errno=True)
generate("void", ["_exit", "_Exit", "quick_exit"], "int status",
         tpl="_exit",
         no_saved_errno=True)
# No wrapper for exit_group() in glibc 2.30.
#generate("void", "exit_group", "int status",
#         tpl="_exit")
skip("exit_group")

# Intercept fork() and variants
generate("pid_t", "fork", "",
         tpl="fork")
# NOTE: Mapping those to fork() breaks the ABI since the fork handlers were not supposed to run for those calls,
#       OTOH the fork handlers notify the supervisor about the calls.
generate("pid_t", ["vfork", "_Fork"], "",
         tpl="fork")

# Intercept system
generate("int", "system", "const char *cmd",
         # ignore calls just checking for available shell
         send_msg_condition="cmd != NULL",
         tpl="system")

# Intercept popen and pclose
generate("FILE *", "popen", "const char *cmd, const char *type",
         tpl="popen")
generate("int", "pclose", "FILE *stream",
         tpl="pclose",
         # Maybe we pclose() an fopen()ed file, in that case send the "close" message (from tpl_pclose.c)
         # but don't send the "pclose" message. See #642 for more info.
         send_msg_condition="was_popened && (success || (errno != EINTR && errno != EFAULT))",
         msg_skip_fields=["stream"],
         msg_add_fields=["fbbcomm_builder_pclose_set_fd(&ic_msg, fd);"],
         send_ret_on_success=True,
         ack_condition="true")

# Intercept the posix_spawn family
generate("int", "posix_spawn", "pid_t *pid, const char *file, " +
                               "const posix_spawn_file_actions_t *file_actions, " +
                               "const posix_spawnattr_t *attrp, " +
                               "char *const argv[], char *const envp[]",
         tpl="posix_spawn",
         success="ret == 0")
generate("int", "posix_spawnp", "pid_t *pid, const char *file, " +
                                "const posix_spawn_file_actions_t *file_actions, " +
                                "const posix_spawnattr_t *attrp, " +
                                "char *const argv[], char *const envp[]",
         tpl="posix_spawn",
         success="ret == 0")

generate("int", ["posix_spawn_file_actions_init", "posix_spawn_file_actions_destroy"], "posix_spawn_file_actions_t *file_actions",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_addopen", "posix_spawn_file_actions_t *file_actions, int fd, const char *pathname, int flags, mode_t mode",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_addclose", "posix_spawn_file_actions_t *file_actions, int fd",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_addclosefrom_np", "posix_spawn_file_actions_t *file_actions, int lowfd",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_adddup2", "posix_spawn_file_actions_t *file_actions, int oldfd, int newfd",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_addchdir_np", "posix_spawn_file_actions_t *file_actions, const char *pathname",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_addfchdir_np", "posix_spawn_file_actions_t *file_actions, int fd",
         tpl="posix_spawn_file_actions",
         success="ret == 0")

# Insert a trace marker for clone and pthread_create
generate("int", "clone", "int (*fn)(void *), void *stack, int flags, void *arg, ...",
         tpl="clone")
generate("int", "pthread_create", "pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg",
         tpl="pthread_create")

# Intercept the wait family
# Need to wait for the supervisor to ACK that it has processed what the child had done
# Lock only for the communication, see #338
generate("pid_t", "wait", "int *wstatus",
         success="ret > 0",
         before_lines=["int wstatus_fallback;",
                       "if (!wstatus) wstatus = &wstatus_fallback;"],
         global_lock='after',
         send_msg_on_error=False,
         msg="wait",
         msg_skip_fields=["wstatus"],
         msg_add_fields=["fbbcomm_builder_wait_set_pid(&ic_msg, ret);",
                         "fbbcomm_builder_wait_set_wstatus(&ic_msg, *wstatus);"],
         ack_condition="true")
generate("pid_t", "waitpid", "pid_t pid, int *wstatus, int options",
         global_lock='after',
         before_lines=["int wstatus_fallback;",
                       "if (!wstatus) wstatus = &wstatus_fallback;"],
         success="ret > 0",
         send_msg_on_error=False,
         send_msg_condition="success && !WIFSTOPPED(*wstatus) && !WIFCONTINUED(*wstatus)",
         msg="wait",
         msg_skip_fields=["pid", "wstatus", "options"],
         msg_add_fields=["fbbcomm_builder_wait_set_pid(&ic_msg, ret);",
                         "fbbcomm_builder_wait_set_wstatus(&ic_msg, *wstatus);"],
         ack_condition="true")
generate("pid_t", "wait3", "int *wstatus, int options, struct rusage *rusage",
         global_lock='after',
         before_lines=["int wstatus_fallback;",
                       "if (!wstatus) wstatus = &wstatus_fallback;"],
         success="ret > 0",
         send_msg_on_error=False,
         send_msg_condition="success && !WIFSTOPPED(*wstatus) && !WIFCONTINUED(*wstatus)",
         msg="wait",
         msg_skip_fields=["wstatus", "options", "rusage"],
         msg_add_fields=["fbbcomm_builder_wait_set_pid(&ic_msg, ret);",
                         "fbbcomm_builder_wait_set_wstatus(&ic_msg, *wstatus);"],
         ack_condition="true")
generate("pid_t", "wait4", "pid_t pid, int *wstatus, int options, struct rusage *rusage",
         global_lock='after',
         before_lines=["int wstatus_fallback;",
                       "if (!wstatus) wstatus = &wstatus_fallback;"],
         success="ret > 0",
         send_msg_on_error=False,
         send_msg_condition="success && !WIFSTOPPED(*wstatus) && !WIFCONTINUED(*wstatus)",
         msg="wait",
         msg_skip_fields=["pid", "wstatus", "options", "rusage"],
         msg_add_fields=["fbbcomm_builder_wait_set_pid(&ic_msg, ret);",
                         "fbbcomm_builder_wait_set_wstatus(&ic_msg, *wstatus);"],
         ack_condition="true")
# Note: See BUGS in the waitid(2) manual page for the infop==NULL case.
generate("int", "waitid", "idtype_t idtype, id_t id, siginfo_t *infop, int options",
         global_lock='after',
         before_lines=["siginfo_t infop_fallback;",
                       "if (!infop) infop = &infop_fallback;"],
         send_msg_on_error=False,
         send_msg_condition="success && !((options & WNOHANG) && (infop->si_pid == 0)) && infop->si_code != CLD_STOPPED && infop->si_code != CLD_TRAPPED && infop->si_code != CLD_CONTINUED",
         msg="wait",
         msg_skip_fields=["idtype", "id", "infop", "options"],
         msg_add_fields=["fbbcomm_builder_wait_set_pid(&ic_msg, infop->si_pid);",
                         "fbbcomm_builder_wait_set_si_code(&ic_msg, infop->si_code);",
                         "fbbcomm_builder_wait_set_si_status(&ic_msg, infop->si_status);"],
         ack_condition="true")

# Intercept the exec family
generate("int", ["execl", "execlp"], "const char *file, const char *arg, ...",
         tpl="exec")
# Note: execlpe exists on some systems, but not in glibc
generate("int", "execle", "const char *file, const char *arg, ...",
         tpl="exec")
generate("int", ["execv", "execvp"], "const char *file, char *const argv[]",
         tpl="exec")
generate("int", ["execve", "execvpe"], "const char *file, char *const argv[], char *const envp[]",
         tpl="exec")
# No wrapper for execveat() in glibc 2.30.
#generate("int", "execveat", "int dirfd, const char *file, char *const argv[], char *const envp[], int flags",
#         tpl="exec")
skip("execveat")
generate("int", "fexecve", "int fd, char *const argv[], char *const envp[]",
         tpl="exec")

# Signal handling
generate("sighandler_t", ["signal", "sigset"], "int signum, sighandler_t handler",
         tpl="signal",
         success="1")
generate("int", "sigaction", "int signum, const struct sigaction *act, struct sigaction *oldact",
         tpl="signal")

# Skip the getcwd family: The initial working directory is part of the fingerprint
skip("getcwd", "getwd", "get_current_dir_name")

# Time and alarm handling: These are fine, no action required
# TODO(rbalint) those may affect output if the process measures time that way
# usually the calls can be ignored
skip("clock", "clock_getres", "clock_getcpuclockid")
skip("sleep", "usleep", "nanosleep", "clock_nanosleep", "pause")
skip("alarm", "ualarm", "getitimer", "setitimer")
skip("timer_create", "timer_delete", "timer_settime", "timer_gettime", "timer_getoverrun")

# Getting high entropy randomness should disable shortcutting
generate("ssize_t", "getrandom", "void* buf, size_t buflen, unsigned int flags",
         msg_skip_fields = ["buf", "buflen"])

# Querying current time - probably disable shortcutting, let the supervisor decide
generate("time_t", "time", "time_t *loc",
         success="true",
         tpl="once")
generate("int", "ftime", "struct timeb *tp",
         tpl="once")
# sys/time.h declares the funcion with void *tz and not matching that generates an error
# generate("int", "gettimeofday", "struct timeval *tv, struct timezone *tz",
generate("int", "gettimeofday", "struct timeval *tv, void *tz",
         tpl="once")
generate("int", "clock_gettime", "clockid_t clk_id, struct timespec *tp",
         tpl="once")
generate("int", ["ntp_gettime", "ntp_gettimex"], "struct ntptimeval *ntv",
         tpl="once")

# Disable setting the time
generate("int", "stime", "const time_t *t",
         tpl="once")
generate("int", "settimeofday", "const struct timeval *tv, const struct timezone *tz",
         tpl="once")
generate("int", "clock_settime", "clockid_t clk_id, const struct timespec *tp",
         tpl="once")
generate("int", "adjtime", "const struct timeval *delta, struct timeval *olddelta",
         tpl="once")
generate("int", "adjtimex", "struct timex *buf",
         tpl="once")
generate("int", "ntp_adjtime", "struct timex *buf",
         tpl="once")

# Skip scheduling parameters
skip("nice", "getpriority", "setpriority", "getrusage", "profil", "acct")
generate("int", "prctl", "int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5",
         tpl="once")

# Process stuff
skip("getpid", "getppid", "getpgrp", "getpgid", "__getpgid", "setpgid", "setpgrp", "setsid", "getsid")
generate("mode_t", "umask", "mode_t mask",
         success="true",
         send_ret_on_success=True,
         send_msg_on_error=False)
# Note: getumask is gone since glibc 2.24

# FIXME {get,set,p}rlimit

# User and group stuff
# FIXME shall we notify the supervisor?
skip("getuid", "getgid", "geteuid", "getegid", "getresuid", "getresgid")
skip("getgroups", "group_member")
generate("int", ["setuid", "seteuid"], "uid_t uid",
         tpl="once")
generate("int", ["setgid", "setegid"], "gid_t gid",
         tpl="once")
generate("int", "setreuid", "uid_t uid, uid_t euid",
         tpl="once")
generate("int", "setregid", "gid_t gid, gid_t egid",
         tpl="once")
generate("int", "setresuid", "uid_t uid, uid_t euid, uid_t suid",
         tpl="once")
generate("int", "setresgid", "gid_t gid, gid_t egid, gid_t sgid",
         tpl="once")
generate("int", "setgroups", "size_t size, const gid_t *list",
         tpl="once")

# Shells
skip("getusershell", "endusershell", "setusershell")

# FIXME What to do with the getpwent() family?

# Tty stuff
skip("ttyname", "ttyname_r", "ttyslot", "isatty", "vhangup", "getpass")
skip("tcgetpgrp", "tcsetpgrp", "getlogin", "getlogin_r")
skip("ctermid", "cuserid")
generate("int", "setlogin", "const char *name",
         tpl="once")

# Revoke - glibc function exists, no manpage. Does it work?
skip("revoke")

# System stuff
skip("daemon")
skip("getpagesize")
skip("getdtablesize")

# Memory management
skip("malloc", "calloc", "realloc", "free", "brk", "sbrk")
# FIXME intercept mmap
skip("mmap", "munmap")

# Hostname stuff - report gethostname, getdomainname, gethostid.
# The supervisor might decide whether to disable shortcutting, or ignore this difference
generate("int", "gethostname", "char *name, size_t len",
         tpl="once")
generate("int", "__gethostname_chk", "char *name, size_t len, size_t fortify_size",
         tpl="once")
generate("int", "getdomainname", "char *name, size_t len",
         tpl="once")
generate("int", "__getdomainname_chk", "char *name, size_t len, size_t fortify_size",
         tpl="once")
generate("long", "gethostid", "",
         tpl="once")

# Disable shortcutting on sethostname, setdomainname, sethostid
generate("int", "sethostname", "const char *name, size_t len",
         tpl="once")
generate("int", "setdomainname", "const char *name, size_t len",
         tpl="once")
generate("int", "sethostid", "long hostid",
         tpl="once")

# Intercept the pathconf family
# FIXME Sometimes a retval == -1 does not denote error. Same for sysconf.
generate("long", "pathconf", "const char *path, int name",
         send_ret_on_success=True)
generate("long", "fpathconf", "int fd, int name",
         send_ret_on_success=True)

# Intercept sysconf
# FIXME Sometimes a retval == -1 does not denote error. Same for pathconf.
generate("long", "sysconf", "int name",
         send_ret_on_success=True)

# Intercept syscall
# FIXME retval == -1 does not have a generic meaning
generate("long", "syscall", "long number, ...",
         tpl="syscall",
         send_ret_on_success=True,
         ack_condition="true")

# FIXME This is temporary only, until intercepting confstr is implemented:
#generate("size_t", "confstr", "int name, char *buf, size_t len")
skip("confstr")

# Network
# FIXME use the "once" template instead: we need to know it can't be shortcut
skip("socket", "socketpair", "getsockname", "bind", "connect", "getpeername")
skip("send", "recv", "sendto", "recvfrom", "sendmsg", "recvmsg")
skip("getsockopt", "setsockopt", "listen", "accept", "accept4", "shutdown", "sockatmark")

# Mounts
skip("setmntent", "getmntent", "getmntent_r", "addmntent", "endmntent", "hasmntopt")

# FIXME Implement intercepting these:
# mkdir(at)
# freopen(64) - looks complicated

# locale related ones:
# (bind)textdomain, *gettext, {set,use,new}locale, nl_langinfo, iconv*
# iswalpha, towlower and friends (the locale dependant ones)
# strcasecmp
# strerror*, strsignal, strftime
# *_l


# Finally rename the output files.
for gen in outputs:
  os.rename(outdir + "/gen_" + gen + tmpsuffix, outdir + "/gen_" + gen)
