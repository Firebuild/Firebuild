#!/usr/bin/python3

# Copyright (c) 2014 Balint Reczey <balint@balintreczey.hu>
# Copyright (c) 2020 Interri Kft.
# This file is an unpublished work. All rights reserved.


import sys
from jinja2 import Environment, FileSystemLoader


if len(sys.argv) != 2:
  print("Usage: ./generate_interceptors outputdir", file=sys.stderr)
  exit(1)
outdir = sys.argv[1]

outputs = ['decl.h', 'def.c', 'impl.c', 'init.c', 'reset.c']
env = Environment(loader=FileSystemLoader('.'),
                  line_statement_prefix='###',
                  trim_blocks=True,
                  lstrip_blocks=True,
                  keep_trailing_newline=True)


# Best effort to try to debug as many parameters as easily doable.
def add_debug_to_dict(type, name, dict):
  debug_type_to_when_and_how = {
    "int":           ("before", "%d"),
    "unsigned int":  ("before", "%u"),
    "mode_t":        ("before", "%u"),
    "uid_t":         ("before", "%u"),
    "gid_t":         ("before", "%u"),
    "long":          ("before", "%ld"),
    "ssize_t":       ("before", "%ld"),
    "off_t":         ("before", "%ld"),
    "off64_t":       ("before", "%ld"),
    "unsigned long": ("before", "%lu"),
    "size_t":        ("before", "%lu"),
    "const char *":  ("before", "\\\"%s\\\""),
    "char *":        ("after",  "\\\"%s\\\""),  # assume the call modifies, so log at the end
    "FILE *":        ("before", "%p"),
    "DIR *":         ("before", "%p"),
  }

  if type in debug_type_to_when_and_how:
    (when, fmt) = debug_type_to_when_and_how[type]

    if name == 'ret':
      when = "after"

    dict['debug_' + when + '_fmt'] += ", " + name + "=" + fmt
    dict['debug_' + when + '_args'] += ", " + name


# Given a method signature (return type, types and names of parameters)
# as strings, generates various values for the convenience of templates.
# Supports arrays, but does not support function pointers.
#
# For the debug info to work, requires a space before the start,
# e.g. "char *" and not "char*".
#
# E.g.
#           rettype = "int"
#               sig = "const char *pathname, int flags, int pipefd[2], ..."
# ->
#             types = ["const char *", "int", "int[2]"]
#             names = ["pathname, "flags", "pipefd"]
#   types_and_names = [("const char *", "pathname"), ("int", "flags"), ("int[2]", "pipefd")]
#            vararg = True
#         types_str = "const char *, int, int[2], ..."
#           sig_str = "const char *pathname, int flags, int pipefd[2], ..."
#         names_str = "pathname, flags, pipefd"
#
#  debug_before_fmt ≈ ", pathname = \"%s\", flags = %d"
# debug_before_args ≈ ", pathname, flags"
#   debug_after_fmt ≈ ", ret = %d"
#  debug_after_args ≈ ", ret"
def add_signature_to_dict(rettype, sig, dict):
  dict['types'] = []
  dict['names'] = []
  dict['types_and_names'] = []
  dict['vararg'] = False
  dict['sig_str'] = sig

  dict['debug_before_fmt'] = ''
  dict['debug_before_args'] = ''
  dict['debug_after_fmt'] = ''
  dict['debug_after_args'] = ''

  if sig != '':
    for type_and_name in sig.split(','):
      type_and_name = type_and_name.strip()
      if type_and_name == '...':
        dict['vararg'] = True
      else:
        pos = max(type_and_name.rfind('*') + 1, type_and_name.rfind(' ') + 1)
        type = type_and_name[:pos].strip()
        name = type_and_name[pos:].strip()
        # Move "[]" or "[number]" from the end of name to the end of type
        pos = name.rfind('[')
        if pos >= 0:
          type += name[pos:]
          name = name[:pos]
        dict['types'].append(type)
        dict['names'].append(name)
        dict['types_and_names'].append((type, name))

        add_debug_to_dict(type, name, dict)

  dict['types_str'] = ', '.join(dict['types'])
  if dict['vararg']:
    dict['types_str'] += ', ...'
  dict['names_str'] = ', '.join(dict['names'])

  add_debug_to_dict(rettype, 'ret', dict)

  return dict


# Keep track of the functions we've already generated.
generated={}


# Generate stuff for the given libc / kernel method.
#
# Makes sure to exit with an error if there's a skip() or another
# generate() call somewhere else for the same method.
#
# rettype: method's return type, as string
# funcs: one or more function names, as (list of) string
# sig: the function signature, as string
# tpl: the template file to use, default is 'tpl.c'
# msg: the protobuf message, default is the first func
# success: the success condition, default depends on rettype
# dict: further parameters to pass to the template,
#       see the template for their documentation
def generate(rettype, funcs, sig, **dict):
  if type(funcs) == str:
    funcs = [funcs]

  if 'tpl' not in dict:
    dict['tpl'] = 'tpl.c'
  else:
    dict['tpl'] = 'tpl_' + dict['tpl'] + '.c'
  template = env.get_template(dict['tpl'])

  if 'msg' not in dict:
    dict['msg'] = funcs[0]

  if 'success' not in dict:
    if rettype == 'void':
      dict['success'] = "true /* default success condition for void rettype */"
    elif '*' in rettype:
      dict['success'] = "ret != NULL /* default success condition for pointer rettype */"
    else:
      dict['success'] = "ret >= 0 /* default success condition for scalar rettype */"

  add_signature_to_dict(rettype, sig, dict)

  for func in funcs:
    if func in generated:
      print("generate_interceptors: Error: Already generated '" + func + "'", file=sys.stderr)
      exit(1)
    generated[func] = True

    for gen in outputs:
      rendered = template.render(gen=gen, rettype=rettype, func=func, **dict)
      if rendered:
        with open(outdir + "/gen_" + gen, "a") as f:
          f.write(rendered)


# Do not intercept the given libc / kernel method.
#
# This does two things:
#
# Creates a "#define ic_orig_func func" redirect so that you can always
# call ic_orig_foo() in the interceptor code, without worrying whether
# that method is overridden or not.
#
# Also makes sure to exit with an error if there's a
# generate() call somewhere else for the same method.
#
# You can pass multiple function names at once.
def skip(*list):
  for func in list:
    generate('', func, '',
             tpl="skip")


# Initialize the output files with their headers.
# Also truncate them before we'll reopen them plenty of times for appending.
for gen in outputs:
  with open(outdir + "/gen_" + gen, "w") as f:
    f.write("/* Auto-generated by generate_interceptors, do not edit */\n\n")


# Intercept vararg open() and friends
generate("int", ["open", "open64"], "const char *file, int flags, ...",
         tpl="open",
         after_lines=["if (i_am_intercepting) clear_file_state(ret);"],
         send_ret_on_success=True,
         ack=True)
generate("int", ["openat", "openat64"], "int dirfd, const char *file, int flags, ...",
         tpl="open",
         after_lines=["if (i_am_intercepting) clear_file_state(ret);"],
         msg="open",
         send_ret_on_success=True,
         ack=True)

# Intercept open_2 variants
generate("int", ["__open_2", "__open64_2"], "const char *file, int flags",
         after_lines=["if (i_am_intercepting) clear_file_state(ret);"],
         msg="open",
         send_ret_on_success=True,
         ack=True)
generate("int", ["__openat_2", "__openat64_2"], "int dirfd, const char *file, int flags",
         after_lines=["if (i_am_intercepting) clear_file_state(ret);"],
         msg="open",
         send_ret_on_success=True,
         ack=True)

# Intercept fopen
# Note: confusingly open()'s and fopen()'s manual uses the word "mode" for something completely different.
generate("FILE *", ["fopen", "fopen64"], "const char *file, const char *mode",
         after_lines=["int fd = safe_fileno(ret);",
                      "if (i_am_intercepting) clear_file_state(fd);"],
         msg="open",
         msg_skip_fields=["mode"],
         msg_add_fields=["m->set_flags(intercept_fopen_mode_to_open_flags_helper(mode));",
                         "m->set_mode(0666);",
                         "if (success) m->set_ret(fd);"])

# Intercept freopen
# FIXME implement in the supervisor. Note that the behavior heavily depends on filename's nullness.
#generate("FILE *", ["freopen", "freopen64"], "const char *filename, const char *mode, FILE *stream",
#         before_lines=["int oldfd = safe_fileno(stream);",
#                       "if (i_am_intercepting) clear_file_state(oldfd);"],
#         after_lines=["int newfd = safe_fileno(ret);",
#                      "if (i_am_intercepting) clear_file_state(newfd);"],
#         msg_skip_fields=["mode", "stream"],
#         msg_add_fields=["m->set_flags(intercept_fopen_mode_to_open_flags_helper(mode));",
#                         "m->set_fd(oldfd);",
#                         "if (success) m->set_ret(newfd);"])
generate("FILE *", ["freopen", "freopen64"], "const char *filename, const char *mode, FILE *stream",
         tpl="once")

skip("fdopen")  # High level stream operation only

# FIXME add support for shm_open and memfd_create
generate("int", "shm_open", "const char *name, int oflag, mode_t mode",
         tpl="once")
generate("int", "memfd_create", "const char *name, unsigned int flags",
         tpl="once")

# Intercept close and fclose
# Don't call the actual method on the supervisor connection fd.
generate("int", "close", "int fd",
         before_lines=["if (fd != fb_sv_conn) {",
                       "  if (i_am_intercepting) clear_file_state(fd);"],
         after_lines=["} else { ret = -1; saved_errno = EBADF; }"],
         ack=True)
generate("int", "fclose", "FILE *stream",
         before_lines=["int fd = safe_fileno(stream); /* save it here, we can't do fileno() after the fclose() */",
                       "if (fd != fb_sv_conn) {",
                       "  if (i_am_intercepting) clear_file_state(fd);"],
         after_lines=["} else { ret = -1 /* a.k.a. EOF */; saved_errno = EBADF; }"],
         msg="close",
         msg_skip_fields=["stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)

skip("fcloseall")  # Only closes the high level streams, not the underlying fds.

# Intercept opendir, closedir (no need to intercept fdopendir)
generate("DIR *", "opendir", "const char *file",
         msg="open",
         msg_add_fields=["m->set_flags(O_RDONLY | O_CLOEXEC | O_DIRECTORY);",
                         "if (success) m->set_ret(ic_orig_dirfd(ret));"],
         ack=True)
generate("int", "closedir", "DIR *dirp",
         before_lines=["int fd = safe_dirfd(dirp); /* save it here, we can't do dirfd() after the closedir() */"],
         msg="close",
         msg_skip_fields=["dirp"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
# FIXME implement scandir(at)(64)

# FIXME Intercept mkdir
#generate("int", "mkdir", "const char *pathname, mode_t mode")
#generate("int", "mkdirat", "int dirfd, const char *pathname, mode_t mode",
#         msg="mkdir")

# Intercept the remove, rmdir, unlink families
generate("int", ["unlink", "remove"], "const char *pathname")
generate("int", "unlinkat", "int dirfd, const char *pathname, int flags",
         msg="unlink")
generate("int", "rmdir", "const char *dir")

# Intercept the rename family
generate("int", "rename", "const char *oldpath, const char *newpath")
generate("int", "renameat", "int oldfd, const char *oldpath, int newfd, const char *newpath",
         msg="rename")
generate("int", "renameat2", "int oldfd, const char *oldpath, int newfd, const char *newpath, unsigned int flags",
         msg="rename")

# Intercept operations that read from a file descriptor.
# FIXME also intercept mmap with PROT_READ
generate("ssize_t", "read", "int fd, void *buf, size_t count",
         tpl="read",
         msg_skip_fields=["buf", "count"],
         ack=True)
generate("ssize_t", "readv", "int fd, const struct iovec *iov, int iovcnt",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt"],
         ack=True)
generate("ssize_t", "pread", "int fd, void *buf, size_t count, off_t offset",
         tpl="read",
         msg_skip_fields=["buf", "count", "offset"],
         ack=True)
generate("ssize_t", "pread64", "int fd, void *buf, size_t count, off64_t offset",
         tpl="read",
         msg_skip_fields=["buf", "count", "offset"],
         ack=True)
generate("ssize_t", "preadv", "int fd, const struct iovec *iov, int iovcnt, off_t offset",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt", "offset"],
         ack=True)
generate("ssize_t", "preadv64", "int fd, const struct iovec *iov, int iovcnt, off64_t offset",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt", "offset"],
         ack=True)
generate("ssize_t", "preadv2", "int fd, const struct iovec *iov, int iovcnt, off_t offset, int flags",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt", "offset", "flags"],
         ack=True)
generate("ssize_t", "preadv64v2", "int fd, const struct iovec *iov, int iovcnt, off64_t offset, int flags",
         tpl="read",
         msg_skip_fields=["iov", "iovcnt", "offset", "flags"],
         ack=True)
generate("size_t", ["fread", "fread_unlocked"], "void *ptr, size_t size, size_t nmemb, FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         success="ret > 0 || !ferror(stream)",  # unused anyway
         msg_skip_fields=["ptr", "size", "nmemb", "stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("int", ["fgetc", "fgetc_unlocked", "getc", "getc_unlocked", "getw"], "FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         msg_skip_fields=["stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("wint_t", ["fgetwc", "fgetwc_unlocked", "getwc", "getwc_unlocked"], "FILE *stream",
         tpl="read",
         success="ret != WEOF",
         before_lines=["int fd = safe_fileno(stream);"],
         msg_skip_fields=["stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("char *", ["fgets", "fgets_unlocked"], "char *s, int size, FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         msg_skip_fields=["s", "size", "stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("int", ["getchar", "getchar_unlocked"], "",
         tpl="read",
         before_lines=["int fd = safe_fileno(stdin);"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("wint_t", ["getwchar", "getwchar_unlocked"], "",
         tpl="read",
         success="ret != WEOF",
         before_lines=["int fd = safe_fileno(stdin);"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("char *", "gets", "char *s",  # should be never used, see man gets
         tpl="read",
         before_lines=["int fd = safe_fileno(stdin);"],
         msg_skip_fields=["s"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("FB_SSIZE_T", "getline", "char **lineptr, size_t *n, FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stream);"],
         msg_skip_fields=["lineptr", "n", "stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("FB_SSIZE_T", ["getdelim", "__getdelim"], "char **lineptr, size_t *n, int delim, FILE *stream",
         tpl="read",
         before_lines=["int fd = safe_fileno(stdin);"],
         msg_skip_fields=["lineptr", "n", "delim", "stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
# Handle (__isoc99_)?v?f?w?scanf
for i in ['', '__isoc99_']:
  for v in ['', 'v']:
    for f in ['', 'f']:
      for w in ['', 'w']:
        func = i + v + f + w + "scanf"
        if f == '':
          sig_str = ''
          names_str = ''
          before_lines = ["int fd = safe_fileno(stdin);"]
          msg_skip_fields = []
          msg_add_fields = ["m->set_fd(fd);"]
        elif f == 'f':
          sig_str = "FILE *stream, "
          names_str = "stream, "
          before_lines = ["int fd = safe_fileno(stream);"]
          msg_skip_fields = ["stream"]
          msg_add_fields = ["m->set_fd(fd);"]
        if w:
          sig_str += "const wchar_t *format, "
        else:
          sig_str += "const char *format, "
        names_str += "format, "
        msg_skip_fields += ["format"]
        if v:
          sig_str += "FB_VA_LIST ap"
          call_orig_lines = None
          msg_skip_fields += ["ap"]
        else:
          sig_str += "..."
          call_orig_lines = ["ret = ic_orig_" + i + "v" + f + w + "scanf(" + names_str + "ap);"]
        generate("int", func, sig_str,
                 tpl="read",
                 before_lines=before_lines,
                 call_orig_lines=call_orig_lines,
                 msg_skip_fields=msg_skip_fields,
                 msg_add_fields=msg_add_fields,
                 ack=True)
for i in ['', '__isoc99_']:
  for v in ['', 'v']:
    for w in ['', 'w']:
      skip(i + v + "s" + w + "scanf")

# Intercept operations that write to a file descriptor.
# FIXME also intercept mmap with PROT_WRITE
generate("ssize_t", "write", "int fd, const void *buf, size_t count",
         tpl="write",
         msg_skip_fields=["buf", "count"],
         ack=True)
generate("ssize_t", "writev", "int fd, const struct iovec *iov, int iovcnt",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt"],
         ack=True)
generate("ssize_t", "pwrite", "int fd, const void *buf, size_t count, off_t offset",
         tpl="write",
         msg_skip_fields=["buf", "count", "offset"],
         ack=True)
generate("ssize_t", "pwrite64", "int fd, const void *buf, size_t count, off64_t offset",
         tpl="write",
         msg_skip_fields=["buf", "count", "offset"],
         ack=True)
generate("ssize_t", "pwritev", "int fd, const struct iovec *iov, int iovcnt, off_t offset",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt", "offset"],
         ack=True)
generate("ssize_t", "pwritev64", "int fd, const struct iovec *iov, int iovcnt, off64_t offset",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt", "offset"],
         ack=True)
generate("ssize_t", "pwritev2", "int fd, const struct iovec *iov, int iovcnt, off_t offset, int flags",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt", "offset", "flags"],
         ack=True)
generate("ssize_t", "pwritev64v2", "int fd, const struct iovec *iov, int iovcnt, off64_t offset, int flags",
         tpl="write",
         msg_skip_fields=["iov", "iovcnt", "offset", "flags"],
         ack=True)
generate("size_t", ["fwrite", "fwrite_unlocked"], "const void *ptr, size_t size, size_t nmemb, FILE *stream",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         success="ret > 0 || !ferror(stream)",  # unused anyway
         msg_skip_fields=["ptr", "size", "nmemb", "stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("int", ["fputc", "fputc_unlocked", "putc", "putc_unlocked", "putw"], "int c, FILE *stream",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         msg_skip_fields=["c", "stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("wint_t", ["fputwc", "fputwc_unlocked", "putwc", "putwc_unlocked"], "wchar_t wc, FILE *stream",
         tpl="write",
         success="ret != WEOF",
         before_lines=["int fd = safe_fileno(stream);"],
         msg_skip_fields=["wc", "stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("int", ["fputs", "fputs_unlocked"], "const char *s, FILE *stream",
         tpl="write",
         before_lines=["int fd = safe_fileno(stream);"],
         msg_skip_fields=["s", "stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("int", ["putchar", "putchar_unlocked"], "int c",
         tpl="write",
         before_lines=["int fd = safe_fileno(stdout);"],
         msg_skip_fields=["c"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("wint_t", ["putwchar", "putwchar_unlocked"], "wchar_t wc",
         tpl="write",
         success="ret != WEOF",
         before_lines=["int fd = safe_fileno(stdout);"],
         msg_skip_fields=["wc"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("int", "puts", "const char *s",
         tpl="write",
         before_lines=["int fd = safe_fileno(stdout);"],
         msg_skip_fields=["s"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
generate("void", "perror", "const char *s",
         tpl="write",
         before_lines=["int fd = safe_fileno(stderr);"],
         msg_skip_fields=["s"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)
# Handle v?[fd]?w?printf
for v in ['', 'v']:
  for f in ['', 'f', 'd']:
    for w in ['', 'w']:
      func = v + f + w + "printf"
      if f == '':
        sig_str = ''
        names_str = ''
        before_lines = ["int fd = safe_fileno(stdout);"]
        msg_skip_fields = []
        msg_add_fields = ["m->set_fd(fd);"]
      elif f == 'f':
        sig_str = "FILE *stream, "
        names_str = "stream, "
        before_lines = ["int fd = safe_fileno(stream);"]
        msg_skip_fields = ["stream"]
        msg_add_fields = ["m->set_fd(fd);"]
      elif f == 'd':
        sig_str = "int fd, "
        names_str = "fd, "
        before_lines = []
        msg_skip_fields = []
        msg_add_fields = []
      if w:
        sig_str += "const wchar_t *format, "
      else:
        sig_str += "const char *format, "
      names_str += "format, "
      msg_skip_fields += ["format"]
      if v:
        sig_str += "FB_VA_LIST ap"
        call_orig_lines = None
        msg_skip_fields += ["ap"]
      else:
        sig_str += "..."
        call_orig_lines = ["ret = ic_orig_v" + v + f + w + "printf(" + names_str + "ap);"]
      generate("int", func, sig_str,
               tpl="write",
               before_lines=before_lines,
               call_orig_lines=call_orig_lines,
               msg_skip_fields=msg_skip_fields,
               msg_add_fields=msg_add_fields,
               ack=True)
for v in ['', 'v']:
  for w in ['', 'w', 'n']:
    skip(v + "s" + w + "printf")
skip("asprintf", "vasprintf")

# Intercept chdir and fchdir
generate("int", "chdir", "const char *dir")
generate("int", "fchdir", "int fd")

# Intercept the chmod family
generate("int", "chmod", "const char *path, mode_t mode")
generate("int", "lchmod", "const char *path, mode_t mode",
         msg="chmod",
         msg_add_fields=["m->set_link(true);"])
# fchmodat() is badly named, should be chmodat()
generate("int", "fchmodat", "int dirfd, const char *path, mode_t mode, int flags",
         msg="chmod",
         msg_add_fields=["if (flags & AT_SYMLINK_NOFOLLOW) m->set_link(true);"])
generate("int", "fchmod", "int fd, mode_t mode")

# Intercept the chown family
generate("int", "chown", "const char *path, uid_t owner, gid_t group")
generate("int", "lchown", "const char *path, uid_t owner, gid_t group",
         msg="chown",
         msg_add_fields=["m->set_link(true);"])
# fchownat() is badly named, should be chownat()
generate("int", "fchownat", "int dirfd, const char *path, uid_t owner, gid_t group, int flags",
         msg="chown",
         msg_add_fields=["if (flags & AT_SYMLINK_NOFOLLOW) m->set_link(true);"])
generate("int", "fchown", "int fd, uid_t owner, gid_t group")

# Intercept the link, symlink and readlink families
generate("int", "link", "const char *oldpath, const char *newpath")
generate("int", "linkat", "int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags",
         msg="link")
generate("int", "symlink", "const char *oldpath, const char *newpath")
generate("int", "symlinkat", "const char *oldpath, int newdirfd, const char *newpath",
         msg="symlink")
generate("ssize_t", "readlink", "const char *path, char *buf, size_t bufsiz",
         tpl="readlink",
         msg_skip_fields=["buf"])
generate("ssize_t", "readlinkat", "int dirfd, const char *path, char *buf, size_t bufsiz",
         tpl="readlink",
         msg="readlink",
         msg_skip_fields=["buf"])
# FIXME realpath

# Intercept the stat family
generate("int", "__xstat", "int ver, const char *filename, struct stat *stat_buf",
         msg="stat",
         msg_skip_fields=["ver", "stat_buf"])
generate("int", "__xstat64", "int ver, const char *filename, struct stat64 *stat_buf",
         msg="stat",
         msg_skip_fields=["ver", "stat_buf"])
generate("int", "__lxstat", "int ver, const char *filename, struct stat *stat_buf",
         msg="stat",
         msg_skip_fields=["ver", "stat_buf"],
         msg_add_fields=["m->set_link(true);"])
generate("int", "__lxstat64", "int ver, const char *filename, struct stat64 *stat_buf",
         msg="stat",
         msg_skip_fields=["ver", "stat_buf"],
         msg_add_fields=["m->set_link(true);"])
generate("int", "__fxstat", "int ver, int fd, struct stat *stat_buf",
         msg="fstat",
         msg_skip_fields=["ver", "stat_buf"])
generate("int", "__fxstat64", "int ver, int fd, struct stat64 *stat_buf",
         msg="fstat",
         msg_skip_fields=["ver", "stat_buf"])
# fstatat() is badly named, should be statat()
generate("int", "__fxstatat", "int ver, int dirfd, const char *filename, struct stat *stat_buf, int flags",
         msg="stat",
         msg_skip_fields=["ver", "stat_buf", "flags"],
         msg_add_fields=["if (flags & AT_SYMLINK_NOFOLLOW) m->set_link(true);"])
generate("int", "__fxstatat64", "int ver, int dirfd, const char *filename, struct stat64 *stat_buf, int flags",
         msg="stat",
         msg_skip_fields=["ver", "stat_buf", "flags"],
         msg_add_fields=["if (flags & AT_SYMLINK_NOFOLLOW) m->set_link(true);"])
# since glibc 2.28
generate("int", "statx", "int dirfd, const char *filename, int flags, unsigned int mask, struct statx *statx_buf",
         msg="stat",
         msg_skip_fields=["flags", "mask", "statx_buf"],
         msg_add_fields=["if (flags & AT_SYMLINK_NOFOLLOW) m->set_link(true);"])
# Treat isfdtype() as a fstat()
generate("int", "isfdtype", "int fd, int fdtype",
         msg="fstat",
         msg_skip_fields=["fdtype"])

# Disable shortcutting on the statfs family
generate("int", "ustat", "dev_t dev, struct ustat *ubuf",
         tpl="once")
generate("int", "statfs", "const char *path, struct statfs *buf",
         tpl="once")
generate("int", "statfs64", "const char *path, struct statfs64 *buf",
         tpl="once")
generate("int", "fstatfs", "int fd, struct statfs *buf",
         tpl="once")
generate("int", "fstatfs64", "int fd, struct statfs64 *buf",
         tpl="once")
generate("int", "statvfs", "const char *path, struct statvfs *buf",
         tpl="once")
generate("int", "statvfs64", "const char *path, struct statvfs64 *buf",
         tpl="once")
generate("int", "fstatvfs", "int fd, struct statvfs *buf",
         tpl="once")
generate("int", "fstatvfs64", "int fd, struct statvfs64 *buf",
         tpl="once")

# Intercept lockf */
generate("int", "lockf", "int fd, int cmd, off_t len")
generate("int", "lockf64", "int fd, int cmd, off64_t len",
         msg="lockf")

# Intercept fcntl and fcntl64
generate("int", ["fcntl", "fcntl64"], "int fd, int cmd, ...",
         tpl="fcntl",
         send_ret_on_success=True)

# Intercept ioctl
generate("int", "ioctl", "int fd, unsigned long cmd, ...",
         send_ret_on_success=True)

# Intercept the dup family
generate("int", "dup", "int oldfd",
         after_lines=["copy_file_state(ret, oldfd);"],
         send_ret_on_success=True)
generate("int", "dup2", "int oldfd, int newfd",
         after_lines=["copy_file_state(newfd, oldfd);"],
         msg="dup3")
generate("int", "dup3", "int oldfd, int newfd, int flags",
         after_lines=["copy_file_state(newfd, oldfd);"])

# Intercept access variants
generate("int", "access", "const char *pathname, int mode")
generate("int", "euidaccess", "const char *pathname, int mode")
# eaccess() is handled in ic_redirect_only.cc
generate("int", "faccessat", "int dirfd, const char *pathname, int mode, int flags")

# Intercept the (l)utime family
generate("int", "utime", "const char *file, const struct utimbuf *times",
         msg_skip_fields=["times"])
generate("int", "utimes", "const char *file, const struct timeval times[2]",
         msg="utime",
         msg_skip_fields=["times"])
generate("int", "lutimes", "const char *file, const struct timeval times[2]",
         msg="utime",
         msg_skip_fields=["times"],
         msg_add_fields=["m->set_link(true);"])
generate("int", "utimensat", "int dirfd, const char *file, const struct timespec times[2], int flags",
         msg="utime",
         msg_skip_fields=["times", "flags"],
         msg_add_fields=["if (flags & AT_SYMLINK_NOFOLLOW) m->set_link(true);"])
# futimesat is badly named and badly designed, and is obsoleted by utimensat
generate("int", "futimesat", "int dirfd, const char *file, const struct timeval times[2]",
         msg="utime",
         msg_skip_fields=["times"])

# Intercept the futime family
generate("int", "futimes", "int fd, const struct timeval times[2]",
         msg="futime",
         msg_skip_fields=["times"])
generate("int", "futimens", "int fd, const struct timespec times[2]",
         msg="futime",
         msg_skip_fields=["times"])

# Intercept dlopen
# The new library's constructor may generate intercepted calls
generate("void *", "dlopen", "const char *filename, int flag",
         tpl="dlopen",
         before_lines=["thread_intercept_on = NULL;"],
         after_lines=["thread_intercept_on = \"dlopen\";"])
generate("void *", "dlmopen", "Lmid_t lmid, const char *filename, int flag",
         tpl="dlopen",
         msg="dlopen",
         msg_skip_fields=["lmid"],
         before_lines=["thread_intercept_on = NULL;"],
         after_lines=["thread_intercept_on = \"dlmopen\";"])

# Intercept the pipe family
generate("int", "pipe", "int pipefd[2]",
         after_lines=["if (success && i_am_intercepting) { clear_file_state(pipefd[0]); clear_file_state(pipefd[1]); }"],
         msg="pipe2",
         msg_skip_fields=["pipefd"],
         msg_add_fields=["if (success) { m->set_fd0(pipefd[0]); m->set_fd1(pipefd[1]); }"])
generate("int", "pipe2", "int pipefd[2], int flags",
         after_lines=["if (success && i_am_intercepting) { clear_file_state(pipefd[0]); clear_file_state(pipefd[1]); }"],
         msg_skip_fields=["pipefd"],
         msg_add_fields=["if (success) { m->set_fd0(pipefd[0]); m->set_fd1(pipefd[1]); }",
                         "m->set_flags(flags);"])

# Intercept the truncate family
generate("int", "truncate", "const char *path, off_t len")
generate("int", "truncate64", "const char *path, off64_t len",
         msg="truncate")
generate("int", "ftruncate", "int fd, off_t len")
generate("int", "ftruncate64", "int fd, off64_t len",
         msg="ftruncate")

# Intercept the mkstemp family
# Note: these update the file template in place.
generate("int", "mkstemp", "char *file",
         send_msg_on_error=False,
         msg="open",
         msg_add_fields=["m->set_flags(O_RDWR | O_CREAT | O_EXCL);",
                         "m->set_mode(0600);"],
         send_ret_on_success=True,
         ack=True)
generate("int", "mkostemp", "char *file, int flags",
         send_msg_on_error=False,
         msg="open",
         msg_skip_fields=["flags"],
         msg_add_fields=["m->set_flags(O_RDWR | O_CREAT | O_EXCL | (flags & (O_APPEND | O_CLOEXEC | O_SYNC)));",
                         "m->set_mode(0600);"],
         send_ret_on_success=True,
         ack=True)
generate("int", "mkstemps", "char *file, int suffixlen",
         send_msg_on_error=False,
         msg="open",
         msg_skip_fields=["suffixlen"],
         msg_add_fields=["m->set_flags(O_RDWR | O_CREAT | O_EXCL);",
                         "m->set_mode(0600);"],
         send_ret_on_success=True,
         ack=True)
generate("int", "mkostemps", "char *file, int suffixlen, int flags",
         send_msg_on_error=False,
         msg="open",
         msg_skip_fields=["suffixlen", "flags"],
         msg_add_fields=["m->set_flags(O_RDWR | O_CREAT | O_EXCL | (flags & (O_APPEND | O_CLOEXEC | O_SYNC)));",
                         "m->set_mode(0600);"],
         send_ret_on_success=True,
         ack=True)
#  generate("char *", "mkdtemp", "char *dir",
#           send_msg_on_error=False,
#           msg="mkdir",
#           msg_add_fields=["m->set_mode(0700);"],
#           ack=True)
# FIXME needs support on the supervisor for starting to track an fd without knowing the backing file
generate("FILE *", ["tmpfile", "tmpfile64"], "",
         tpl="once")
# "Never use these functions"
# FIXME Supporting them would require supervisor work, or two messages (exclusive open, then close)
generate("char *", ["mktemp", "tmpnam", "tmpnam_r"], "char *tmplt",
         tpl="once")
generate("char *", ["tempnam"], "const char *dir, const char *pfx",
         tpl="once")

# Disable shortcutting on chroot
generate("int", "chroot", "const char *path",
         tpl="once")

# Skip bridge between low and high level io
skip("fileno", "dirfd")

# Skip directory reading
skip("readdir", "readdir64", "readdir_r", "readdir64_r", "rewinddir", "seekdir", "telldir")
skip("getdents", "getdents64", "getdirentries", "getdirentries64")
# FIXME implement scandir(at)(64)

# Disable shortcutting on mknod
# Note: there's no "mknod" symbol exported by glibc, only "__xmknod(at)"
generate("int", "__xmknod", "int ver, const char *path, mode_t mode, dev_t *dev",
         tpl="once")
generate("int", "__xmknodat", "int ver, int dirfd, const char *path, mode_t mode, dev_t *dev",
         tpl="once")

# Disable shortcutting on mkfifo
generate("int", "mkfifo", "const char *pathname, mode_t mode",
         tpl="once")
generate("int", "mkfifoat", "int dirfd, const char *pathname, mode_t mode",
         tpl="once")

# Intercept the exit family.
# - _exit() and _Exit() terminate the process immediately, no exit handlers are run.
#   So we need to modify the supervisor about the exit code and resource usage before execuing it.
# - exit() calls the atexit() / on_exit() handlers first. We'll notify the supervisor using the
#   hopefully last on_exit() handler, which is our on_exit_handler() method.
# - quick_exit() calls the at_quick_exit() handlers, which, similarly to the atexit() handlers,
#   do not receive the exit status. So notify the supervisor before calling this method, just like
#   for _exit().
generate("void", ["exit"], "int status",
         tpl="exit",
         no_saved_errno=True)
generate("void", ["_exit", "_Exit", "quick_exit"], "int status",
         tpl="_exit",
         no_saved_errno=True)
# No wrapper for exit_group() in glibc 2.30.
#generate("void", "exit_group", "int status",
#         tpl="_exit")
skip("exit_group")

# Intercept fork
generate("pid_t", "fork", "",
         tpl="fork")

# Intercept system
generate("int", "system", "const char *cmd",
         tpl="system")

# Intercept popen and pclose
generate("FILE *", "popen", "const char *cmd, const char *type",
         tpl="popen")
generate("int", "pclose", "FILE *stream",
         before_lines=["int fd = safe_fileno(stream); /* save it here, we can't do fileno() after the pclose() */"],
         msg_skip_fields=["stream"],
         msg_add_fields=["m->set_fd(fd);"],
         ack=True)

# Intercept the posix_spawn family
# FIXME Check the error condition. The manpage is weird:
# "these functions return an error number" suggesting that the
# error code is returned directly (as in the kernel interface),
# rather than stored in errno.
generate("int", "posix_spawn", "pid_t *pid, const char *file, " +
                               "const posix_spawn_file_actions_t *file_actions, " +
                               "const posix_spawnattr_t *attrp, " +
                               "char *const argv[], char *const envp[]",
         tpl="posix_spawn",
         success="ret == 0")
generate("int", "posix_spawnp", "pid_t *pid, const char *file, " +
                                "const posix_spawn_file_actions_t *file_actions, " +
                                "const posix_spawnattr_t *attrp, " +
                                "char *const argv[], char *const envp[]",
         tpl="posix_spawn",
         success="ret == 0")

generate("int", ["posix_spawn_file_actions_init", "posix_spawn_file_actions_destroy"], "posix_spawn_file_actions_t *file_actions",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_addopen", "posix_spawn_file_actions_t *file_actions, int fd, const char *path, int flags, mode_t mode",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_addclose", "posix_spawn_file_actions_t *file_actions, int fd",
         tpl="posix_spawn_file_actions",
         success="ret == 0")
generate("int", "posix_spawn_file_actions_adddup2", "posix_spawn_file_actions_t *file_actions, int oldfd, int newfd",
         tpl="posix_spawn_file_actions",
         success="ret == 0")

# Intercept the wait family
# Need to wait for the supervisor to ACK that it has processed what the child had done
generate("pid_t", "wait", "int *wstatus",
         success="ret > 0",
         send_msg_on_error=False,
         msg="wait",
         msg_skip_fields=["wstatus"],
         msg_add_fields=["m->set_pid(ret);"],
         ack=True)
generate("pid_t", "waitpid", "pid_t pid, int *wstatus, int options",
         before_lines=["int wstatus_fallback;",
                       "if (!wstatus) wstatus = &wstatus_fallback;"],
         success="ret > 0",
         send_msg_on_error=False,
         send_msg_condition="success && !WIFSTOPPED(*wstatus) && !WIFCONTINUED(*wstatus)",
         msg="wait",
         msg_skip_fields=["pid", "wstatus", "options"],
         msg_add_fields=["m->set_pid(ret);"],
         ack=True)
generate("pid_t", "wait3", "int *wstatus, int options, struct rusage *rusage",
         before_lines=["int wstatus_fallback;",
                       "if (!wstatus) wstatus = &wstatus_fallback;"],
         success="ret > 0",
         send_msg_on_error=False,
         send_msg_condition="success && !WIFSTOPPED(*wstatus) && !WIFCONTINUED(*wstatus)",
         msg="wait",
         msg_skip_fields=["wstatus", "options", "rusage"],
         msg_add_fields=["m->set_pid(ret);"],
         ack=True)
generate("pid_t", "wait4", "pid_t pid, int *wstatus, int options, struct rusage *rusage",
         before_lines=["int wstatus_fallback;",
                       "if (!wstatus) wstatus = &wstatus_fallback;"],
         success="ret > 0",
         send_msg_on_error=False,
         send_msg_condition="success && !WIFSTOPPED(*wstatus) && !WIFCONTINUED(*wstatus)",
         msg="wait",
         msg_skip_fields=["pid", "wstatus", "options", "rusage"],
         msg_add_fields=["m->set_pid(ret);"],
         ack=True)
# Note: See BUGS in the waitid(2) manual page for the infop==NULL case.
generate("int", "waitid", "idtype_t idtype, id_t id, siginfo_t *infop, int options",
         send_msg_on_error=False,
         send_msg_condition="success && infop && !((options & WNOHANG) && (infop->si_pid == 0)) && infop->si_code != CLD_STOPPED && infop->si_code != CLD_TRAPPED && infop->si_code != CLD_CONTINUED",
         msg="wait",
         msg_skip_fields=["idtype", "id", "infop", "options"],
         msg_add_fields=["m->set_pid(infop->si_pid);"],
         ack=True)

# Intercept the exec family
generate("int", ["execl", "execlp"], "const char *file, const char *arg, ...",
         tpl="exec")
# Note: execlpe exists on some systems, but not in glibc
generate("int", "execle", "const char *file, const char *arg, ...",
         tpl="exec")
generate("int", ["execv", "execvp"], "const char *file, char *const argv[]",
         tpl="exec")
generate("int", ["execve", "execvpe"], "const char *file, char *const argv[], char *const envp[]",
         tpl="exec")
# No wrapper for execveat() in glibc 2.30.
#generate("int", "execveat", "int dirfd, const char *file, char *const argv[], char *const envp[], int flags",
#         tpl="exec")
skip("execveat")
generate("int", "fexecve", "int fd, char *const argv[], char *const envp[]",
         tpl="exec")

# Intercept main
# Note: Our parser parses this method signature completely wrong. This is not a problem since only the original string is used.
generate("int", "__libc_start_main", "int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end",
         tpl="main",
         global_lock=False,
         no_saved_errno=True)

# Signal handling
generate("sighandler_t", ["signal", "sigset"], "int signum, sighandler_t handler",
         tpl="signal",
         success="1")
generate("int", "sigaction", "int signum, const struct sigaction *act, struct sigaction *oldact",
         tpl="signal")

# Skip the getcwd family: The initial working directory is part of the fingerprint
skip("getcwd", "getwd", "get_current_dir_name")

# Time and alarm handling: These are fine, no action required
# TODO(rbalint) those may affect output if the process measures time that way
# usually the calls can be ignored
skip("clock", "clock_getres", "clock_getcpuclockid")
skip("sleep", "usleep", "nanosleep", "clock_nanosleep", "pause")
skip("alarm", "ualarm", "getitimer", "setitimer")
skip("timer_create", "timer_delete", "timer_settime", "timer_gettime", "timer_getoverrun")

# Querying current time - probably disable shortcutting, let the supervisor decide
generate("time_t", "time", "time_t *loc",
         success="true",
         tpl="once")
generate("int", "ftime", "struct timeb *tp",
         tpl="once")
# sys/time.h declares the funcion with void *tz and not matching that generates an error
# generate("int", "gettimeofday", "struct timeval *tv, struct timezone *tz",
generate("int", "gettimeofday", "struct timeval *tv, void *tz",
         tpl="once")
generate("int", "clock_gettime", "clockid_t clk_id, struct timespec *tp",
         tpl="once")
generate("int", ["ntp_gettime", "ntp_gettimex"], "struct ntptimeval *ntv",
         tpl="once")

# Disable setting the time
generate("int", "stime", "const time_t *t",
         tpl="once")
generate("int", "settimeofday", "const struct timeval *tv, const struct timezone *tz",
         tpl="once")
generate("int", "clock_settime", "clockid_t clk_id, const struct timespec *tp",
         tpl="once")
generate("int", "adjtime", "const struct timeval *delta, struct timeval *olddelta",
         tpl="once")
generate("int", "adjtimex", "struct timex *buf",
         tpl="once")
generate("int", "ntp_adjtime", "struct timex *buf",
         tpl="once")

# Skip scheduling parameters
skip("nice", "getpriority", "setpriority", "getrusage", "profil", "acct")
generate("int", "prctl", "int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5",
         tpl="once")

# Process stuff
skip("getpid", "getppid", "getpgrp", "getpgid", "__getpgid", "setpgid", "setpgrp", "setsid", "getsid")
# FIXME Allow these, but store the old umask as the initial state in the supervisor
generate("mode_t", "umask", "mode_t mask",
         success="true",
         tpl="once")
generate("mode_t", "getumask", "",
         success="true",
         tpl="once")

# FIXME {get,set,p}rlimit

# User and group stuff
# FIXME shall we notify the supervisor?
skip("getuid", "getgid", "geteuid", "getegid", "getresuid", "getresgid")
skip("getgroups", "group_member")
generate("int", ["setuid", "seteuid"], "uid_t uid",
         tpl="once")
generate("int", ["setgid", "setegid"], "gid_t gid",
         tpl="once")
generate("int", "setreuid", "uid_t uid, uid_t euid",
         tpl="once")
generate("int", "setregid", "gid_t gid, gid_t egid",
         tpl="once")
generate("int", "setresuid", "uid_t uid, uid_t euid, uid_t suid",
         tpl="once")
generate("int", "setresgid", "gid_t gid, gid_t egid, gid_t sgid",
         tpl="once")
generate("int", "setgroups", "size_t size, const gid_t *list",
         tpl="once")

# Shells
skip("getusershell", "endusershell", "setusershell")

# FIXME What to do with the getpwent() family?

# Tty stuff
skip("ttyname", "ttyname_r", "ttyslot", "isatty", "vhangup", "getpass")
skip("tcgetpgrp", "tcsetpgrp", "getlogin", "getlogin_r")
skip("ctermid", "cuserid")
generate("int", "setlogin", "const char *name",
         tpl="once")

# Revoke - glibc function exists, no manpage. Does it work?
skip("revoke")

# System stuff
skip("daemon")
skip("getpagesize")
skip("getdtablesize")

# Memory management
skip("malloc", "calloc", "realloc", "free", "brk", "sbrk")
# FIXME intercept mmap
skip("mmap", "munmap")

# Hostname stuff - report gethostname, getdomainname, gethostid.
# The supervisor might decide whether to disable shortcutting, or ignore this difference
generate("int", "gethostname", "char *name, size_t len",
         tpl="once")
generate("int", "getdomainname", "char *name, size_t len",
         tpl="once")
generate("long", "gethostid", "",
         tpl="once")

# Disable shortcutting on sethostname, setdomainname, sethostid
generate("int", "sethostname", "const char *name, size_t len",
         tpl="once")
generate("int", "setdomainname", "const char *name, size_t len",
         tpl="once")
generate("int", "sethostid", "long hostid",
         tpl="once")

# Intercept the pathconf family
# FIXME Sometimes a retval == -1 does not denote error. Same for sysconf.
generate("long", "pathconf", "const char *path, int name",
         send_ret_on_success=True)
generate("long", "fpathconf", "int fd, int name",
         send_ret_on_success=True)

# Intercept sysconf
# FIXME Sometimes a retval == -1 does not denote error. Same for pathconf.
generate("long", "sysconf", "int name",
         send_ret_on_success=True)

# Intercept syscall
# FIXME retval == -1 does not have a generic meaning
generate("long", "syscall", "long number, ...",
         tpl="syscall",
         send_ret_on_success=True,
         ack=True)

# FIXME This is temporary only, until intercepting confstr is implemented:
#generate("size_t", "confstr", "int name, char *buf, size_t len")
skip("confstr")

# Network
# FIXME use the "once" template instead: we need to know it can't be shortcut
skip("socket", "socketpair", "getsockname", "bind", "connect", "getpeername")
skip("send", "recv", "sendto", "recvfrom", "sendmsg", "recvmsg")
skip("getsockopt", "setsockopt", "listen", "accept", "accept4", "shutdown", "sockatmark")

# Mounts
skip("setmntent", "getmntent", "getmntent_r", "addmntent", "endmntent", "hasmntopt")

# FIXME Implement intercepting these:
# mkdir(at)
# freopen(64) - looks complicated

# locale related ones:
# (bind)textdomain, *gettext, {set,use,new}locale, nl_langinfo, iconv*
# iswalpha, towlower and friends (the locale dependant ones)
# strcasecmp
# strerror*, strsignal, strftime
# *_l
